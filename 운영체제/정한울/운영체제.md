# 운영체제

---

# 시그널, 인터럽트

## 시그널

프로세스 간 통신(IPC, Inter-Process Communication)의 한 형태. 
운영체제가 프로세스에게 어떤 **이벤트가 발생**했음을 알리기 위해 보내는 **비동기적** 알림.

**특징**

- 비동기
- 경량 통신 : 메세지 큐나 소켓보다 빠르고 가벼움

### 시그널 처리 흐름

1. **시그널 발생**
    
    이벤트가 발생하면 커널은 **해당 프로세스의 PCB(Process Control Block)** 내에 **pending 시그널 비트맵**에 시그널을 기록
    
2. **시그널 대기열에 등록 (Pending Queue)**
    
    해당 시그널 번호에 해당하는 비트를 `1`로 설정
    
    여러 개의 같은 시그널이 발생해도 중복 저장 안 됨
    
3. **프로세스가 실행 상태로 전환될 때 시그널 확인**
    
    시그널이 pending 상태인지 확인
    
    해당 시그널이 **block(mask)** 되어 있지 않으면 처리 시작
    
4. **시그널 처리 방식 결정 (Default / Ignore / Handler)**
    - 기본 동작(Default) : 예: 종료, 무시, 중단, 계속 등
    - 무시(Ignore) : `SIG_IGN` 지정 시 해당 시그널 무시
    - 사용자 정의 핸들러 : `signal()`이나 `sigaction()`으로 정의한 함수 실행
5. **시그널 처리 수행**
6. **처리 완료 후 복귀**

## 인터럽트

CPU가 외부나 내부의 이벤트에 즉시 반응하도록 강제로 현재 작업을 중단시키는 메커니즘.
이 이벤트가 인터럽트.

**종류**

- 하드웨어 인터럽트 : I/O 장치나 타이머 같은 외부 장치가 CPU에 신호 보냄 (예: 키보드 입력)
- 소프트웨어 인터럽트 : 프로그램이 직접 발생시킴 (예: 시스템 콜)

### 인터럽트 처리 흐름

1. **인터럽트 발생**
    
    하드웨어(예: 키보드, 타이머) 또는 소프트웨어(예: 예외, 시스템 호출)에 의해 발생.
    
2. **현재 작업 저장**
    
    CPU는 현재 실행 중이던 작업의 상태(레지스터, PC 등)를 **스택에 저장**해둠.
    
3. **인터럽트 벡터 확인**
    
    어떤 종류의 인터럽트인지 식별하고, 해당 인터럽트에 등록된 인터럽트 핸들러(ISR: Interrupt Service Routine)로 점프.
    
4. **인터럽트 처리**
    
    ISR 코드 실행. 예를 들어 키보드 입력이면 입력된 값을 버퍼에 저장.
    
5. **원래 작업 복귀**
    
    저장해 둔 작업 상태를 복원하고, CPU는 중단했던 작업을 계속 실행.
    

## 인터럽트 vs 시그널

| 항목 | **인터럽트 (Interrupt)** | **시그널 (Signal)** |
| --- | --- | --- |
| 발생 위치 | 하드웨어 or 커널 내부 | 커널 → 사용자 프로세스 |
| 처리 대상 | CPU / 커널 수준 | 유저 프로세스 |
| 주요 목적 | CPU에 즉시 주의를 끌기 위함 | 프로세스에게 특정 이벤트 발생을 알림 |
| 예시 | 키보드 입력, 타이머, 네트워크 | `SIGINT`, `SIGSEGV`, `SIGKILL` 등 |

# CPU 스케줄링

---

# 문제

1. 예외가 발생할 때 어떻게 되는가
    1. NullPointerException
        1. 자바에서는 JVM이 예외 발생시킴
            
            시스템 콜, 시그널과 관련 없음
            
        2. C/C++에서 null 포인터 참조 같은 경우는 시그널(`SIGSEGV`)로 처리
            
            CPU가 해당 명령을 실행하려고 할 때 페이지 폴트(page fault) 발생
            
            페이지 폴트 발생 → 커널에서 프로세스에 시그널 보냄 → 해당 시그널 처리
            
        3. 시스템 콜에서 널 포인터 전달(`write(fd, NULL, 10);`)
            
            커널은 유저 공간 포인터에 접근하려고 하다 예외 발생. 페이지 폴트.
            
            커널이 -1 리턴
            
            2번 케이스랑 좀 다른 점. 
            
            시스템 콜 내부에서는 커널이 사용자 포인터를 접근하기 전에 `copy_from_user()`, `access_ok()` 같은 보호 함수를 먼저 씀.
            
            - 이걸로 NULL이거나 잘못된 포인터면 커널은 **아예 접근을 하지 않음**
            - 대신 안전하게 `EFAULT` 반환함
            - `SIGSEGV`처럼 프로세스를 죽이지 않고, **정상적인 시스템 콜 실패**로 처리
    2. 산술 예외(arithmetic exception)
        
        0으로 나누는 예외는 시그널 `SIGFPE` (Floating Point Exception)로 처리됨
        
        - CPU가 하드웨어 예외(division fault)를 발생 → 운영체제 커널이 그걸 감지하여 해당 프로세스에 `SIGFPE`를 전달
        
2. OS가 시그널 상태를 확인하는 시점은 언제?
    1. 프로세스가 사용자 모드로 돌아가기 직전
        
        시스템 콜, 인터럽트, 트랩 처리 후 커널 모드에서 사용자 모드로 복귀할 때
        
        즉, `read()`, `write()` 같은 시스템 콜을 마치고 돌아가는 시점
        
    2. 프로세스가 스케줄러에 의해 다시 실행 상태로 전환될 때
        
        sleep 상태였다가 wakeup 될 때, 또는 새로 스케줄링되어 CPU를 다시 할당받을 때
        
        컨텍스트 스위칭도 포함
        
    3. 프로세스가 특정 대기 함수(예: `pause()`, `sigwait()`)로 시그널을 기다릴 때