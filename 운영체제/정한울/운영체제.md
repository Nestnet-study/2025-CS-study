# 운영체제

---

# 시그널, 인터럽트

## 시그널

프로세스 간 통신(IPC, Inter-Process Communication)의 한 형태. 
운영체제가 프로세스에게 어떤 **이벤트가 발생**했음을 알리기 위해 보내는 **비동기적** 알림.

**특징**

- 비동기
- 경량 통신 : 메세지 큐나 소켓보다 빠르고 가벼움

### 시그널 처리 흐름

1. **시그널 발생**
    
    이벤트가 발생하면 커널은 **해당 프로세스의 PCB(Process Control Block)** 내에 **pending 시그널 비트맵**에 시그널을 기록
    
2. **시그널 대기열에 등록 (Pending Queue)**
    
    해당 시그널 번호에 해당하는 비트를 `1`로 설정
    
    여러 개의 같은 시그널이 발생해도 중복 저장 안 됨
    
3. **프로세스가 실행 상태로 전환될 때 시그널 확인**
    
    시그널이 pending 상태인지 확인
    
    해당 시그널이 **block(mask)** 되어 있지 않으면 처리 시작
    
4. **시그널 처리 방식 결정 (Default / Ignore / Handler)**
    - 기본 동작(Default) : 예: 종료, 무시, 중단, 계속 등
    - 무시(Ignore) : `SIG_IGN` 지정 시 해당 시그널 무시
    - 사용자 정의 핸들러 : `signal()`이나 `sigaction()`으로 정의한 함수 실행
5. **시그널 처리 수행**
6. **처리 완료 후 복귀**

## 인터럽트

CPU가 외부나 내부의 이벤트에 즉시 반응하도록 강제로 현재 작업을 중단시키는 메커니즘.
이 이벤트가 인터럽트.

**종류**

- 하드웨어 인터럽트 : I/O 장치나 타이머 같은 외부 장치가 CPU에 신호 보냄 (예: 키보드 입력)
- 소프트웨어 인터럽트 : 프로그램이 직접 발생시킴 (예: 시스템 콜)

### 인터럽트 처리 흐름

1. **인터럽트 발생**
    
    하드웨어(예: 키보드, 타이머) 또는 소프트웨어(예: 예외, 시스템 호출)에 의해 발생.
    
2. **현재 작업 저장**
    
    CPU는 현재 실행 중이던 작업의 상태(레지스터, PC 등)를 **스택에 저장**해둠.
    
3. **인터럽트 벡터 확인**
    
    어떤 종류의 인터럽트인지 식별하고, 해당 인터럽트에 등록된 인터럽트 핸들러(ISR: Interrupt Service Routine)로 점프.
    
4. **인터럽트 처리**
    
    ISR 코드 실행. 예를 들어 키보드 입력이면 입력된 값을 버퍼에 저장.
    
5. **원래 작업 복귀**
    
    저장해 둔 작업 상태를 복원하고, CPU는 중단했던 작업을 계속 실행.
    

## 인터럽트 vs 시그널

| 항목 | **인터럽트 (Interrupt)** | **시그널 (Signal)** |
| --- | --- | --- |
| 발생 위치 | 하드웨어 or 커널 내부 | 커널 → 사용자 프로세스 |
| 처리 대상 | CPU / 커널 수준 | 유저 프로세스 |
| 주요 목적 | CPU에 즉시 주의를 끌기 위함 | 프로세스에게 특정 이벤트 발생을 알림 |
| 예시 | 키보드 입력, 타이머, 네트워크 | `SIGINT`, `SIGSEGV`, `SIGKILL` 등 |

# CPU 스케줄링

---

# 가상 메모리

- **개념**:
    - 실제 물리적 RAM 용량의 한계를 극복하고, 프로그램들이 실제 메모리보다 더 큰 공간을 사용하는 것처럼 보이게 하는 기술.
    - 실제 메모리와 보조 저장 장치(하드 디스크/SSD)의 일부를 조합하여 거대한 가상 메모리 공간 생성.
- **필요성**:
    1. **메모리 부족 문제 해결**: 물리 메모리 부족 시에도 더 많은/큰 프로그램 실행 가능.
    2. **메모리 공유 용이**: 여러 프로세스가 동일 코드/데이터 공유 시 효율성 증대.
    3. **프로세스 격리 및 보호**: 독립적인 가상 주소 공간으로 프로세스 간 침범 방지, 시스템 안정성 향상.
    4. **프로그램 개발 용이성**: 프로그래머가 물리 메모리 크기 신경 쓰지 않고 개발 가능.
- **작동 방식 (주로 페이징 기법)**:
    1. **가상 주소 vs 물리 주소**:
        - **가상 주소**: CPU가 생성하는 논리적 주소.
        - **물리 주소**: 실제 RAM의 메모리 셀 주소.
        - **MMU(Memory Management Unit)**: 가상 주소를 물리 주소로 변환하는 하드웨어 장치.
    2. **페이지(Page) vs 프레임(Frame)**:
        - **페이지**: 가상 메모리 공간을 나눈 고정 크기 블록.
        - **프레임**: 물리 메모리 공간을 나눈 고정 크기 블록 (페이지와 동일 크기).
        - 필요에 따라 페이지는 물리 메모리 프레임에 적재되거나, 당장 필요 없으면 디스크의 **스왑 영역(Swap Area)**에 저장.
    3. **페이지 테이블(Page Table)**:
        - 각 프로세스별로 존재.
        - 가상 페이지 번호에 해당하는 물리 프레임 번호 매핑 정보 포함.
        - 페이지가 물리 메모리에 없을 경우(디스크에 있다면) 해당 정보 포함.
    4. **페이지 폴트(Page Fault)**:
        - CPU가 특정 가상 주소를 참조했는데, 해당 가상 페이지가 현재 물리 메모리에 없는 경우 발생.
        - **처리 과정**:
            1. MMU가 페이지 테이블 확인 후 페이지 부재 감지.
            2. MMU가 CPU에 **페이지 폴트 예외(Page Fault Exception)** 발생.
            3. 운영체제가 페이지 폴트 핸들러 실행.
            4. 디스크 스왑 영역에서 해당 페이지를 물리 메모리로 로드 (**스왑 인**).
            5. 물리 메모리가 가득 찬 경우, **페이지 교체 알고리즘** (예: LRU, FIFO 등)을 사용하여 현재 물리 메모리에 있는 페이지 중 하나를 선택하여 디스크로 내보냄 (**스왑 아웃**).
            6. 페이지가 물리 메모리에 적재되면 페이지 테이블을 업데이트하고, 중단되었던 명령어 실행을 다시 시작.
- **장단점**:
    - **장점**:
        - 프로그램 크기 제약 완화.
        - 다중 프로그래밍 효율 증가.
        - 메모리 할당 및 관리 단순화.
        - 보안성 향상.
    - **단점**:
        - **성능 저하 가능성**: 페이지 폴트가 자주 발생하면 디스크 I/O가 빈번해져 시스템 성능 저하 (→ **쓰레싱(Thrashing)**).
        - 복잡한 구현.
        - MMU와 같은 추가 하드웨어 필요.

# I/O 시스템

- **개념**:
    - Input/Output(입출력)의 약자.
    - 컴퓨터 시스템 내에서 데이터를 입력하고 출력하는 모든 작업과 장치들을 관리하는 운영체제의 부분.
    - 키보드 입력, 화면 출력, 디스크 읽기/쓰기, 네트워크 통신 등 모든 데이터 이동 포함.
- **필요성**:
    1. **다양한 I/O 장치 관리**: 각기 다른 작동 방식과 속도를 가진 다양한 장치들을 효율적이고 통일된 방식으로 관리.
    2. **성능 최적화**: 느린 I/O 작업으로 인한 CPU 대기 시간 최소화, 버퍼링, 스케줄링 등으로 시스템 전체 효율 증대.
    3. **장치 독립성 제공**: 개발자가 장치 종류에 관계없이 공통된 방식으로 I/O 작업 수행 가능하도록 추상화된 인터페이스 제공.
    4. **오류 처리 및 복구**: I/O 장치 오류 감지 및 처리로 시스템 안정성 유지.
    5. **보안 및 보호**: 잘못된 I/O 접근으로부터 시스템과 데이터 보호.
- **구성 요소 및 작동 방식**:
    1. **I/O 하드웨어**:
        - **I/O 장치**: 키보드, 마우스, 디스크, 네트워크 카드 등 실제 입출력 수행 장치.
        - **장치 컨트롤러**: 각 I/O 장치별 고유 컨트롤러. 장치와 CPU/메모리 간 인터페이스, 장치 제어 및 데이터 버퍼링.
        - **버스(Bus)**: CPU, 메모리, I/O 컨트롤러 간 데이터 통로 (물리적 배선). (예: PCIe, USB).
    2. **I/O 소프트웨어 스택**:
        - **애플리케이션 계층**: 사용자 프로그램이 `read()`, `write()` 등 시스템 호출로 I/O 요청.
        - **장치 독립적 I/O 소프트웨어**: 장치 드라이버에 독립적인 일반 I/O 기능 제공 (버퍼링, 캐싱, 스케줄링, 오류 처리, 파일 시스템 등).
        - **장치 드라이버**: 특정 I/O 장치 및 컨트롤러 제어 소프트웨어. 장치 컨트롤러 레지스터 직접 조작, 장치별 특성 캡슐화.
        - **인터럽트 핸들러**: I/O 작업 완료 시 장치 컨트롤러의 인터럽트 발생을 처리.
    3. **I/O 데이터 전송 방식**:
        - **프로그램 제어 I/O (PIO)**: CPU가 I/O 장치 상태 계속 확인(폴링)하며 데이터 직접 전송. CPU 효율 매우 낮음.
        - **인터럽트 기반 I/O**: CPU가 명령 후 다른 작업 수행, 장치 완료 시 인터럽트 발생. CPU가 데이터 전송 자체에는 관여.
        - **DMA (Direct Memory Access)**:
            - **DMA 컨트롤러**라는 전용 하드웨어 장치가 CPU 개입 없이 I/O 장치와 메모리 간 직접 데이터 전송.
            - CPU는 명령만 내리고 다른 작업 수행. 전송 완료 시 DMA 컨트롤러가 CPU에 한 번만 인터럽트 발생.
            - 대용량 데이터 고속 전송에 필수적.
- **I/O 시스템의 주요 기능**:
    - **버퍼링(Buffering)**: 임시 저장 공간(버퍼)으로 CPU-I/O 장치 속도 차이 완화.
    - **캐싱(Caching)**: 자주 사용되는 데이터 빠른 메모리(캐시)에 저장하여 접근 시간 단축.
    - **스풀링(Spooling)**: 공유 장치(프린터) 출력물을 디스크에 임시 저장 후 일괄 처리하여 장치 공유 효율 증대.
    - **장치 스케줄링(Device Scheduling)**: 여러 I/O 요청 시 처리 순서 결정 (예: 디스크 스케줄링 - FCFS, SSTF, SCAN)으로 성능 최적화.
    - **오류 처리(Error Handling)**: I/O 장치 오류 감지 및 복구 메커니즘 제공.

---

# 문제

1. 예외가 발생할 때 어떻게 되는가
    1. NullPointerException
        1. 자바에서는 JVM이 예외 발생시킴
            
            시스템 콜, 시그널과 관련 없음
            
        2. C/C++에서 null 포인터 참조 같은 경우는 시그널(`SIGSEGV`)로 처리
            
            CPU가 해당 명령을 실행하려고 할 때 페이지 폴트(page fault) 발생
            
            페이지 폴트 발생 → 커널에서 프로세스에 시그널 보냄 → 해당 시그널 처리
            
        3. 시스템 콜에서 널 포인터 전달(`write(fd, NULL, 10);`)
            
            커널은 유저 공간 포인터에 접근하려고 하다 예외 발생. 페이지 폴트.
            
            커널이 -1 리턴
            
            2번 케이스랑 좀 다른 점. 
            
            시스템 콜 내부에서는 커널이 사용자 포인터를 접근하기 전에 `copy_from_user()`, `access_ok()` 같은 보호 함수를 먼저 씀.
            
            - 이걸로 NULL이거나 잘못된 포인터면 커널은 **아예 접근을 하지 않음**
            - 대신 안전하게 `EFAULT` 반환함
            - `SIGSEGV`처럼 프로세스를 죽이지 않고, **정상적인 시스템 콜 실패**로 처리
    2. 산술 예외(arithmetic exception)
        
        0으로 나누는 예외는 시그널 `SIGFPE` (Floating Point Exception)로 처리됨
        
        - CPU가 하드웨어 예외(division fault)를 발생 → 운영체제 커널이 그걸 감지하여 해당 프로세스에 `SIGFPE`를 전달
        
2. OS가 시그널 상태를 확인하는 시점은 언제?
    1. 프로세스가 사용자 모드로 돌아가기 직전
        
        시스템 콜, 인터럽트, 트랩 처리 후 커널 모드에서 사용자 모드로 복귀할 때
        
        즉, `read()`, `write()` 같은 시스템 콜을 마치고 돌아가는 시점
        
    2. 프로세스가 스케줄러에 의해 다시 실행 상태로 전환될 때
        
        sleep 상태였다가 wakeup 될 때, 또는 새로 스케줄링되어 CPU를 다시 할당받을 때
        
        컨텍스트 스위칭도 포함
        
    3. 프로세스가 특정 대기 함수(예: `pause()`, `sigwait()`)로 시그널을 기다릴 때

---