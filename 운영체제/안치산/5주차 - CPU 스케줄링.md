### CPU 스케줄링

다수의 프로세스가 실행 대기 상태일 때, 어떤 프로세스에게 CPU를 할당할지를 결정하는 메커니즘

- 목표
	- CPU 이용률을 최대화
	- 프로세스 응답시간/대기시간 최적화

- 크게 2가지로 나뉨
	- 비선점(Non-preemptive): 프로세스가 스스로 CPU를 반납할 때까지 기다림
	- 선점(Preemptive): 특정 조건에서 운영체제가 강제로 CPU를 회수함

##### 주요 스케줄링 알고리즘

(1) FCFS (First Come First Served)
- 도착한 순서대로 CPU를 할당
- 장점: 단순하고 구현 쉬움
- 단점: Convoy 효과 (긴 작업이 짧은 작업을 지연시킴)

(2) SJF (Shortest Job First)
- 실행 시간이 가장 짧은 프로세스 우선
- 비선점형/선점형(SRT) 둘 다 존재
- 장점: 평균 대기시간 최적화됨
- 단점: 실제로는 실행 시간 예측이 어렵고, 기아 현상 발생 가능

(3) SRT (Shortest Remaining Time)
- SJF의 선점형 버전
	- 새 프로세스가 도착했을 때, 현재 실행 중인 프로세스보다 남은 실행 시간이 더 짧으면 선점
- 장점: 빠른 작업이 우선 실행됨
- 단점: 역시 기아 현상

(4) RR (Round Robin)
- 각 프로세스에 동일한 타임 퀀텀(time quantum)만큼 CPU를 할당
	- 타임 퀀텀이 짧으면 응답성이 좋지만 오버헤드 증가
- 장점: 공정성 보장

(5) 우선순위 스케줄링
- 프로세스마다 우선순위를 부여해서 높은 순위부터 실행
- 선점형/비선점형 모두 가능
- 단점: 우선순위가 낮은 프로세스는 영원히 대기할 수 있음 (기아)
	- 이를 해결하기 위해 에이징(Aging) 같은 기법을 씀

(6) 다단계 큐 스케줄링
- 여러 개의 큐를 만들어 각기 다른 특성의 프로세스들을 분류
- 각 큐에 다른 스케줄링 알고리즘 적용 가능

##### CPU 스케쥴링 성능 지표

- CPU 이용률 (CPU Utilization): CPU가 작업 중인 시간 비율
- 처리량 (Throughput): 단위 시간당 완료된 프로세스 수
- 대기시간 (Waiting Time): 준비 큐에서 대기한 시간
- 응답시간 (Response Time): 요청 후 첫 응답까지 걸린 시간
- 반환시간 (Turnaround Time): 전체 소요 시간 (완료 - 도착)

##### 실무/연결 개념

- 현대 OS는 복합형 스케줄링을 사용함
	- ex. Linux - Completely Fair Scheduler
- 실시간 시스템에서는 데드라인 기반 스케줄링도 중요함
	- ex. EDF(Earliest Deadline First) 등

- ? 멀티코어 시스템에서 타이머 인터럽트는 각 코어별로 어떻게 동작할까?
	- 현대 멀티코어 시스템에서는 각 코어별로 독립적인 타이머 인터럽트가 동작하며, 각 코어는 자신이 실행 중인 프로세스의 스케줄링만 담당
	- 필요 시 전체 코어를 깨우는 브로드캐스트 방식도 있지만, 기본은 개별 관리

- ? 데드라인 기반 스케줄링은 뭐지

- ? Completely Fair Scheduler 동작원리와 장단점은?

- ? 비선점 방식에서 프로세스의 작업 단위는 어떻게 결정되지? 명령어 하나?
	- 

---
### 페이지 교체 알고리즘

(1) OTP (Optimal Page Replacement)
- 원리: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체
- 단점: 미래의 페이지 접근을 예측해야 해서 현실에서는 구현 불가
- 주로 비교 기준으로 쓰임

(2) LRU (Least Recently Used)
- 원리: 가장 오래 전에 참조된 페이지를 교체
- 현실성: OTP보다 현실적이고 자주 쓰임
- 구현: 스택, 카운터 등으로 구현 가능

