### 인터럽트

CPU가 실행 중인 작업의 흐름을 잠시 멈추고, 긴급하게 처리해야 하는 다른 작업을 수행하도록 만드는 메커니즘
##### 인터럽트 종류
- 하드웨어 인터럽트
	- 키보드 입력
	- 네트워크 패킷 수신
	- 타이머 인터럽트 (주기적으로 발생해서 스케줄링할 때 중요)
- 소프트웨어 인터럽트
	- 시스템콜
		- 의도적으로 인터럽트 벡터를 발생시켜 커널 기능을 호출
- 예외
	- CPU 내부에서 발생하는 인터럽트로, 주로 에러 상황
	- 0으로 나누기
	- 페이지 폴트(가상 메모리 접근 실패)
##### 인터럽트 처리 과정
1. CPU가 인터럽트 신호 감지
2. 문맥 교환 준비
	- 현재 실행 중인 프로세스 상태를 PCB(Process Control Block)에 저장
3. 인터럽트 벡터를 통해 해당 인터럽트의 서비스 루틴으로 점프
	- 인터럽트 벡터:
		- 인터럽트별 함수 포인터 테이블
		- 빠르게 핸들러를 찾아주는 역할
4. 인터럽트 서비스 루틴(ISR) 수행
5. 다시 원래 프로세스로 복귀(문맥 복원)

- ? ISR은 커널 메모리 영역에 올라가나?
	- YES
	- 인터럽트는 언제 어디서든 발생할 수 있고, 그걸 처리하는 루틴은 반드시 안정적이고 즉시 실행 가능해야하기 때문
	- 따라서 OS는 커널 공간에 ISR을 두고, 시스템이 부팅될 때 장치 드라이버들이 자신의 ISR을 커널에 등록함

- ? 커널 메모리는 가상 메모리를 사용안하고 고정된 영역 맞지?
	- No
	- 동일하게 가상 메모리로 관리되지만 스왑이 되지 않음 <- 고정 메모리처럼 동작
	- @warning 커널의 모든 부분이 항상 메모리에 올라가있는 것은 아님
		- 커널 코어는 부팅할때 메모리에 고정으로 올라감
			- 메모리 관리, 스케쥴러, 인터럽트 처리 등
		- 하지만 USB 드라이버 같은 커널 모듈은 필요할때만 동적으로 로드함

	- ? 그렇다면 커널 코어는 가상 메모리 대신 바로 물리적 주소에 맵핑하는게 성능상 좋지 않나? 별도의 하드웨어 회로가 필요해서 HPC처럼 고성능이 중요한 특수 케이스를 제외하면 그렇게까지는 안하는건가
		- 보안/안정성/유연성/하드웨어 표준화 때문에 일반 OS는 가상 메모리를 쓴다
		- 또한 별도의 하드웨어 회로가 필요하고, 비용/복잡성 증가 때문에 범용 OS에는 적합하지 않음

- ? 인터럽트 처리하는 도중에 다른 인터럽트가 발생한다면?
	- ISR 실행 시에는 **인터럽트 중첩 허용 여부에 따라 다른 인터럽트는 잠시 마스킹**될 수 있음
	- 일부 고급 시스템에서는 우선순위 인터럽트 허용

---
### 시그널

프로세스 간 비동기 통신의 일종. 특정 이벤트가 발생했음을 알려주는 신호
##### 시그널 vs 소프트웨어 인터럽트
- 비슷한 느낌이지만 다름 ![[Pasted image 20250510144833.png]]

- ! 인터럽트가 처리되는 과정에서 특정 프로세스에 시그널을 전달하는 경우도 있다
	- 잘못된 메모리 접근 -> CPU 예외 -> 현재 실행중인 프로세스에 SIGSEGV 시그널 전달
	- 타이머 인터럽트 -> 타이머 인터럽트 -> 커널 스케쥴링만 처리. 시그널 전달 X
	- 디스크 I/O 완료 -> 디스크 인터럽트 -> 수신 대기중인 프로세스에 SIGIO 시그널 전달
	- 네트워크 패킷 수신 -> NIC 인터럽트 -> 대기중인 프로세스에 알림 (epoll/poll)
		- epoll/poll도 시그널처럼 비동기 이벤트 알림을 처리하는 방법 중 하나![[Pasted image 20250510151911.png]]
		- 시그널은 언제든 끼어들 수 있고, epoll/poll은 프로세스가 “기다리고 있을 때만” 이벤트를 받음
			- 시그널은 I/O를 기다리는 동안 다른 일을 처리할 수 있지만 그만큼 복잡도가 증가함
			- 시그널 -> 이벤트 알림보단 특수 상황(예: 종료, 강제 중단 등)
			- epoll/poll -> 네트워크/파일 I/O 같은 고성능 이벤트 루프의 표준
		- 따라서 보통 고성능 서버에서는 epoll/poll 방식을 주로 사용함
			- 비동기 이벤트지만 동기적으로 감지해서 예측이 쉽다
			- 수천~수만 개의 연결도 안정적으로 처리 가능
			- ex. Node.js, Nginx

		- ? 그럼 epoll/poll 방식에서는 응답을 대기하는 프로세스는 대기 상태에 들어가서 아예 프로세스 스케쥴링에서 제외되나?
			- YES
			- 프로세스가 epoll_wait()를 호출하면:
				1.	커널에 진입해서 지정된 fd들의 상태를 검사
				2.	아직 이벤트가 안 생겼으면 → wait queue에 넣고 sleep 상태로 전환
				3.	이벤트가 발생하면:
					- 커널이 해당 프로세스를 깨우고,
					- epoll_wait()이 깨어나서 이벤트 배열을 리턴함.
##### 커널 모드 vs 유저 모드
- 커널 모드
	- 하드웨어에 직접 접근 가능한 모드
	- CPU의 모든 명령어 실행 가능
	- OS 커널, 드라이버, 저수준 작업 수행 시 사용
	- 인터럽트/시그널 처리는 반드시 커널 모드에서 이루어짐
- 유저 모드
	- 애플리케이션 실행 환경
	- 제한된 권한만 가지고 실행됨
	- 시스템콜을 통해 커널 기능을 요청함

- ? 인터럽트/시그널 처리가 커널 모드에서 이루어지는 이유?
	- 하드웨어 인터럽트는 보안, 안정성, 추상화 계층 유지, 실행 권한 등의 이유로 반드시 커널이 먼저 처리한다
	- 유저 프로세스는 커널이 가공한 이벤트(시그널, I/O 알림 등)만 전달받는다
	- 이 구조 덕분에 유저 프로세스는 하드웨어 세부사항을 몰라도 안전하고 일관되게 동작할 수 있음
##### 시그널 처리 방식
- 기본 동작(Default action): 시스템이 기본으로 정의한 동작을 수행
- 핸들러 등록(Handler): signal()이나 sigaction() 같은 시스템콜로 사용자가 직접 처리 함수를 등록할 수 있음
- 무시(Ignore): 특정 시그널을 무시하도록 설정할 수 있음 (단, SIGKILL, SIGSTOP은 무조건 처리됨)

- ? 서버에서 graceful shutdown이라는건 SIGTERM 같은 종료 요청 시그널에 대해서 커스텀 핸들러를 등록하는건가?
	- YES
	- 커스텀 시그널 핸들러를 등록해둔 걸 실행해서:
		- 새로운 요청을 받지 않도록 막고(리스너 닫기),
		- 현재 진행 중인 요청을 다 마무리하고(예: DB 연결 해제, 큐 정리),
		- 로깅 같은 후처리를 한 다음,
		- 정상 종료(exit 0)

	- @warning SIGKILL(9번 시그널)은 절대 무시 못하고 핸들러도 못 달음


---

### 인터럽트/시그널의 중요성

운영체제는 이벤트 기반 비동기 시스템이고, 인터럽트/시그널 덕분에:
- CPU가 바쁘게 루프 돌 필요 없이 유휴 상태 유지 가능 (I/O 완료 기다림)
- 커널과 사용자 프로그램 간 안전한 전환 가능
- 비동기적 예외/이벤트 처리가 가능 (강제 종료, 알림 등)

##### Node.js (이벤트 루프) vs OS (이벤트 기반 비동기)
- 자바스크립트는 싱글 스레드 이벤트 루프라 무거운 작업이 메인 루프를 막아버리는 구조적 한계가 있음
- OS는 멀티태스킹, 선점 스케줄링, 하드웨어 인터럽트 등으로 이 문제를 회피할 수 있는 구조라서 그런 병목이 일반적으로 발생하지 않음
- 다만 OS도 인터럽트 폭주나 리소스 경합 같은 상황에서는 병목 현상이 생길 수 있음

- ? 자바스크립트도 무거운 작업은 중간중간 인터럽트 걸면 안되나?
	- OS는 하드웨어 레벨에서 인터럽트 처리가 되기 때문에 병목이 적은데
	- 소프트웨어 레벨에서 이런 컨텍스트 스위치가 발생하게 된다면 병목이 너무 심해진다

- ? 자바스크립트의 이벤트 루프에서 CPU 바운드 작업을 효율적으로 처리하려면 어떤 전략들이 필요할까
	- Worker Threads
	- Web Workers
	- Chunking
	- C/C++ Add-ons
	- WebAssembly
	- Clustering
	- 아키텍처 분리

	- ? Worker Thread나 Chunking은 처리결과를 다시 메인스레드에서 활용하려면 제약이 좀 심하던데...
		- Worker Pool + Task Graph 관리
			→ 작업 간 의존성을 DAG(작업 그래프)로 관리해 복잡한 연산도 병렬적으로 깔끔히 처리
		- SharedArrayBuffer + Atomics 최적화
			→ 데이터 복사 비용 없이 메모리를 공유하고, Atomics로 락 없이 동기화
		- 메인 스레드 내 Async Generator/Iterator 활용
			→ 비동기 파이프라인 구성으로 대규모 데이터도 이벤트 루프를 막지 않으면서 처리
		- io_uring/네이티브 Add-on 통합
			→ 고성능 I/O 처리를 위해 커널 레벨 API(io_uring)와 네이티브 코드(C/C++)를 결합
