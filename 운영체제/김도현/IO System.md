
# 1. I/O 개요

운영체제의 주요 동작은 computing(연산) / IO(입출력) 두가지이다. OS는 I/O에 대한 수행과 물리 입출력 장치(HW)를 관리하고 컨트롤한다.


#### **컴퓨터 시스템의 구성**

![](https://i.imgur.com/G2YkWc9.png)
- 하나 또는 그 이상의 CPU 존재
- Bus를 통해 다른 기기에 접근할 수 있고 CPU가 주소값을 이용하여 접근할 수 있는 것은 memory이다.
- 하지만 초기 memory는 비어있는 상태인데 이곳을 채우는 것들은 disk의 데이터로부터 채워진다. (Bus를 이용)
- I/O devices와 CPU는 동시에 같이 작업된다.
- 컨트롤러는 local buffer를 가지고 있다. 예를 들어 읽기 작업이면 disk에서 시작되어 그 내용을 disk controller local buffer에 쓰기 작업을 한다. (= I/O 작업)
- 데이터 전송 작업이 끝나면 컨트롤러에서 interrupt를 발생시켜 CPU에게 알려준다. 



#### **I/O Structure**

입출력 구조는 크게 2가지로 나눌 수 있다. 

1) **동기식 I/O :** I/O 동작이 시작하면 CPU도 기다렸다가 동작이 끝났을 때 같이 동작 가능한 구조

- 다음 interrupt 발생 전까지 CPU는 기다리는 구조
- Wait loop 방식 : 다음 interuppt가 발생할 때 까지 메모리에 계속 접근
- 동기식 방식이기 때문에 최대 하나의 I/O 처리 가능

1) **비동기식 I/O** : I/O 동작이 시작되어도 CPU는 컨트롤러를 통해 다른 작업을 수행할 수 있도록 전달 받을 수 있다.
- 다른 I/O 기기가 동작하고 있는지 확인하기 위한 Device status table가 포함되어있다.

![](https://i.imgur.com/EzJzIFT.png)



## **I/O 입출력 처리 과정**

![](https://i.imgur.com/4HF0dFz.png)

**1. 시작 - 사용자가 요청**
- 사용자 프로그램에서 파일 읽기, 키보드 입력 등의 I/O 작업을 요청합니다.

**2. 커널이 판단**
- 운영체제 커널이 "이미 처리할 수 있는 데이터가 있나?" 확인합니다.
- **있으면**: 바로 결과를 돌려줍니다.
- **없으면**: 실제 하드웨어에서 데이터를 가져와야 합니다.

**3. 하드웨어 처리 요청**
- 커널이 장치 드라이버에게 "이 작업을 처리해달라"고 요청합니다.
- 프로세스는 잠시 대기 상태가 됩니다.

**4. 장치 드라이버 동작**
- 드라이버가 하드웨어 컨트롤러(예: 하드디스크, 네트워크 카드)에게 구체적인 명령을 보냅니다.

**5. 하드웨어 작업 수행**
- 컨트롤러가 실제 하드웨어에서 데이터를 읽거나 쓰는 작업을 합니다.

**6. 완료 알림**
- 작업이 끝나면 컨트롤러가 인터럽트(interrupt)를 발생시켜 "작업 완료!"라고 알립니다.

**7. 결과 전달**
- 드라이버가 데이터를 받아서 커널에 전달하고, 최종적으로 사용자 프로그램이 결과를 받습니다.

이 과정을 통해 우리가 파일을 열거나, 인터넷을 사용하거나, 프린터로 출력하는 등의 모든 I/O 작업이 이루어집니다.


## 2. I/O 하드웨어 구조

### 2-1. I/O 장치의 분류

**블록 장치 (Block Device)**
- **특징**: 고정된 크기의 블록 단위로 데이터 전송
- **예시**: 하드디스크, SSD, CD-ROM
- **접근 방식**: 랜덤 액세스 가능 (임의의 블록에 직접 접근)
- **버퍼링**: 블록 단위로 버퍼링 수행

**문자 장치 (Character Device)**
- **특징**: 바이트 스트림으로 순차적 데이터 전송
- **예시**: 키보드, 마우스, 프린터, 시리얼 포트
- **접근 방식**: 순차 액세스만 가능
- **버퍼링**: 문자 단위 또는 라인 단위 버퍼링

### 2-2. 장치 컨트롤러의 역할

**주요 기능**
- **장치 제어**: 실제 하드웨어 장치를 직접 제어
- **데이터 변환**: CPU가 이해할 수 있는 형태로 데이터 변환
- **에러 처리**: 하드웨어 오류 감지 및 복구
- **상태 관리**: 장치의 현재 상태 정보 제공

**구성 요소**
- **제어 레지스터**: 명령과 제어 정보 저장
- **상태 레지스터**: 장치 상태 정보 저장
- **데이터 레지스터**: 실제 데이터 저장
- **로컬 버퍼**: 임시 데이터 저장 공간


> [!NOTE] **장치 컨트롤러**
> **장치 컨트롤러가 하는 일**:
> 
> 1. 번역 업무
> 
> CPU: "파일을 읽어줘"
> 컨트롤러: 하드디스크가 이해할 수 있는 저수준 명령으로 변환
> 예: "트랙 5, 섹터 10에서 데이터 읽기"
> 
> 2. 중간 관리자 역할
> 
> CPU가 직접 복잡한 하드웨어 제어할 필요 없음
> 컨트롤러가 세부적인 하드웨어 조작 담당
> CPU는 간단한 명령만 주면 됨
> 
> 3. 상태 보고
> 
> 하드웨어 상태를 CPU에게 알려줌
> "지금 디스크가 바쁘다", "작업 완료됐다", "에러 발생했다" 등
> 
> 4. 에러 처리
> 
> 하드웨어에서 문제 발생 시 1차적으로 처리
> 복구 가능한 에러는 자체 해결
> 심각한 에러는 CPU에게 보고


> [!NOTE] 장치 컨트롤러와 DMA컨트롤러 차이점
> **장치 컨트롤러**
>- **역할**: 특정 하드웨어 장치 하나를 전담 관리하는 "장치별 매니저"
>- **위치**: 각 I/O 장치마다 하나씩 붙어있음
>- **기능**: 해당 장치의 제어, 상태 관리, 에러 처리
>
>**DMA 컨트롤러**
>
>- **역할**: 메모리와 I/O 장치 간 데이터 전송을 전담하는 "데이터 운반 전문가"
>- **위치**: 시스템에 보통 하나 (또는 몇 개)
>- **기능**: CPU 대신 대용량 데이터를 직접 전송


### 2-3. 메모리 맵핑 I/O vs 포트 맵핑 I/O

**메모리 맵핑 I/O (Memory-Mapped I/O)**
- **방식**: I/O 장치의 레지스터를 메모리 주소 공간에 할당
- **접근**: 일반적인 메모리 읽기/쓰기 명령어 사용
- **장점**: 단순한 프로그래밍, 캐시 활용 가능
- **단점**: 메모리 주소 공간 소모

**포트 맵핑 I/O (Port-Mapped I/O)**
- **방식**: 별도의 I/O 주소 공간 사용
- **접근**: 특별한 I/O 명령어 (IN, OUT) 사용
- **장점**: 메모리 주소 공간 절약
- **단점**: 특별한 명령어 필요, 프로그래밍 복잡


> [!NOTE] 언제 어떤 방식을 선택하나?
> **CISC 계열 (x86)** → 포트 맵핑 선호
> 
> ```
> Intel의 설계 철학:
> "I/O는 메모리와 다른 별개 영역이다"
> - IN/OUT 명령어로 명확히 구분
> - 메모리 주소 공간 절약
> ```
> 
> **RISC 계열 (ARM)** → 메모리 맵핑 선호
> 
> ```
> RISC의 설계 철학:
> "모든 것을 단순하고 통일된 방식으로"
> - 메모리 접근 명령어만 사용
> - 명령어 세트 단순화
> ```



### 2-4. 버스 시스템과 I/O 연결

**버스의 종류**
- **시스템 버스**: CPU-메모리-I/O 연결하는 주 버스
- **I/O 버스**: I/O 장치들 간의 연결 (PCI, USB 등)
- **장치별 버스**: 특정 장치 전용 (SATA, SCSI 등)

**연결 방식**
- **직접 연결**: CPU가 버스를 통해 직접 I/O 장치 제어
- **DMA 연결**: DMA 컨트롤러가 CPU 대신 메모리-I/O 간 데이터 전송
---

## 3. I/O 처리 방식

### 3-1. 프로그램 I/O (Programmed I/O)

**동작 방식**
- CPU가 직접 I/O 장치 상태를 계속 확인 (폴링)
- 데이터가 준비될 때까지 반복적으로 상태 레지스터 체크
- 준비되면 CPU가 직접 데이터 전송

**장점**
- 구현이 간단
- 하드웨어 요구사항 최소

**단점**
- CPU 시간 낭비 (busy waiting)
- 다른 작업 수행 불가

### 3-2. 인터럽트 기반 I/O (Interrupt-driven I/O)

**동작 방식**
- I/O 요청 후 CPU는 다른 작업 수행
- I/O 완료 시 장치가 인터럽트 신호 발생
- CPU가 인터럽트 처리 후 I/O 작업 완료

**장점**
- CPU 효율성 향상
- 멀티태스킹 가능

**단점**
- 인터럽트 처리 오버헤드
- 대용량 데이터 전송 시 인터럽트 빈발

### 3-3. DMA (Direct Memory Access)

**동작 방식**
- DMA 컨트롤러가 CPU 대신 메모리-I/O 간 직접 데이터 전송
- CPU는 전송 시작만 명령하고 다른 작업 수행
- 전송 완료 시 DMA가 인터럽트로 알림

**장점**
- CPU 부담 최소화
- 대용량 데이터 전송에 효율적
- 높은 전송 속도

**단점**
- 복잡한 하드웨어 필요
- 메모리 버스 경합 가능성
![](https://i.imgur.com/nHYhUya.png)

### 3-4. 사용 시나리오

**프로그램 I/O**: 간단한 임베디드 시스템, 소량 데이터 **인터럽트 I/O**: 일반적인 키보드, 마우스 입력 **DMA**: 대용량 파일 전송, 네트워크 통신, 디스크 I/O


---

## 4. 장치 드라이버

### 드라이버의 역할과 구조

**주요 역할**
- **추상화**: 하드웨어 세부사항을 숨기고 표준 인터페이스 제공
- **장치 제어**: 실제 하드웨어 장치 제어 및 관리
- **데이터 변환**: 운영체제와 하드웨어 간 데이터 형식 변환
- **에러 처리**: 하드웨어 오류 감지 및 복구

**구조적 특징**
- **상위 인터페이스**: 운영체제가 호출하는 표준 함수들
- **하위 인터페이스**: 실제 하드웨어 제어 루틴
- **중간 처리**: 데이터 변환, 버퍼링, 에러 처리

**드라이버의 위치**
- 커널 모드에서 실행
- 운영체제와 하드웨어 사이의 중간 계층
- 장치별로 독립적인 모듈

---

## 5. 버퍼링과 캐싱

### 5-1. 버퍼링의 목적과 종류

**버퍼링의 목적**
- **속도 차이 해결**: CPU와 I/O 장치 간 속도 차이 완화
- **효율성 향상**: 작은 단위 요청을 모아서 큰 단위로 처리
- **동기화**: 생산자-소비자 간 동기화 문제 해결

### 5-2. 단일/이중/순환 버퍼링

### 단일 버퍼링 (Single Buffering)

**구조:**
```
[사용자] ←→ [버퍼] ←→ [I/O 장치]
```

**동작 방식:**
```
1. I/O 장치가 버퍼에 데이터 쓰기
2. 완료되면 사용자가 버퍼에서 데이터 읽기
3. 사용자가 읽기 완료하면 다시 1단계

시간:  |--쓰기--|--읽기--|--쓰기--|--읽기--|
      I/O장치   사용자   I/O장치   사용자
```

**문제점:**
- 쓰는 동안 읽을 수 없음
- 읽는 동안 쓸 수 없음
- **순차적 처리만 가능**

### 이중 버퍼링 (Double Buffering)

**구조:**
```
              [버퍼A]
[사용자] ←→           ←→ [I/O 장치]
              [버퍼B]
```

**동작 방식:**
```
시간1: I/O장치가 버퍼A에 쓰기
시간2: I/O장치가 버퍼B에 쓰기 + 사용자가 버퍼A에서 읽기
시간3: I/O장치가 버퍼A에 쓰기 + 사용자가 버퍼B에서 읽기

시간:  |--A쓰기--|--B쓰기+A읽기--|--A쓰기+B읽기--|
      I/O만      동시처리        동시처리
```

**장점:**
- **동시 입출력 가능**
- 성능 거의 2배 향상

**실제 사용 예:**
```c
// 게임 그래픽 더블 버퍼링
while(게임실행) {
    그래픽카드가 백버퍼에 다음 프레임 그리기;
    화면에는 프론트버퍼 내용 출력;
    
    완료되면 백버퍼 ↔ 프론트버퍼 교체;
}
```

### 순환 버퍼링 (Circular Buffering)

**구조:**
```
     [버퍼1] → [버퍼2]
        ↑         ↓
     [버퍼4] ← [버퍼3]
     
생산자: 다음 버퍼에 데이터 쓰기
소비자: 현재 버퍼에서 데이터 읽기
```

**동작 방식:**
```
초기: 생산자=버퍼1, 소비자=버퍼1

시간1: 생산자가 버퍼1에 쓰기 완료 → 버퍼2로 이동
시간2: 소비자가 버퍼1에서 읽기 + 생산자가 버퍼2에 쓰기
시간3: 소비자가 버퍼2로 이동 + 생산자가 버퍼3으로 이동
...
```

**장점:**
- **연속적인 데이터 스트림에 최적**
- 여러 단계 파이프라인 처리 가능

**사용 예:**
```
동영상 스트리밍:
버퍼1: 현재 재생 중인 프레임
버퍼2: 다음 재생할 프레임
버퍼3: 네트워크에서 받고 있는 프레임
버퍼4: 예비 버퍼
```

### 5-3. I/O 캐시의 역할
#### 캐시 vs 버퍼 차이점
**버퍼:**
- **목적**: 속도 차이 완화, 동기화
- **사용**: 일시적 저장 후 바로 소비
- **예**: 키보드 입력 버퍼
**캐시:**
- **목적**: 재사용을 통한 성능 향상
- **사용**: 자주 쓰는 데이터 장기간 보관
- **예**: 웹 브라우저 캐시


### 캐시의 기능

#### 1. 자주 사용되는 데이터 저장

**지역성의 원리 활용:**
```
시간적 지역성: 방금 읽은 파일을 다시 읽을 확률 높음
공간적 지역성: 읽은 파일 근처의 파일을 읽을 확률 높음

예: Word 문서 편집
- 같은 파일을 계속 읽기/쓰기
- 캐시에 저장해두면 하드디스크 접근 불필요
```

#### 2. 재사용성

**캐시 히트 vs 캐시 미스:**
```
캐시 히트: 원하는 데이터가 캐시에 있음
- 하드디스크 접근 없이 즉시 응답
- 속도: 나노초 단위

캐시 미스: 원하는 데이터가 캐시에 없음  
- 하드디스크에서 읽어온 후 캐시에 저장
- 속도: 밀리초 단위
```

#### 3. 선행 읽기 (Prefetching)

**예측적 데이터 로딩:**
```
사용자가 파일의 첫 부분을 읽으면
→ 나머지 부분도 읽을 가능성 높음
→ 미리 캐시로 가져옴

동영상 재생:
현재 1분짜리 재생 중
→ 2~3분짜리도 미리 캐시에 로드
```

#### 4. 쓰기 지연 (Write-back)

**여러 쓰기를 모아서 처리:**
```
즉시 쓰기 (Write-through):
- 쓰기 요청마다 즉시 디스크에 저장
- 안전하지만 느림

지연 쓰기 (Write-back):
- 캐시에만 쓰고 나중에 디스크에 반영
- 빠르지만 정전 시 데이터 손실 위험
```

### 캐시 정책

#### 읽기 캐시 정책
```
1. 요청된 데이터가 캐시에 있나?
   예 → 캐시에서 반환 (캐시 히트)
   아니오 → 디스크에서 읽어서 캐시에 저장 후 반환

2. 캐시가 가득 찼다면?
   → 교체 정책에 따라 기존 데이터 제거
```

#### 쓰기 캐시 정책
```
Write-through: 캐시+디스크 동시 쓰기
- 장점: 데이터 안전성
- 단점: 느린 속도

Write-back: 캐시만 쓰고 나중에 디스크 반영
- 장점: 빠른 속도  
- 단점: 정전 시 손실 위험
```

#### 교체 정책
LRU, FIFO, LFU


> [!question] #### 레지스터는 CPU안에만 있나? 
> 


> [!question] #### DMA의 단점이 뭘까요?
> 

참고: https://wonsjung.tistory.com/497
