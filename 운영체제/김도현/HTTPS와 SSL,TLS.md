

# HTTP vs HTTPS 기본 개념

### HTTP (HyperText Transfer Protocol)

- **계층**: OSI 7계층 (응용 계층)에서 동작
- **기반 프로토콜**: TCP/IP
- **기본 포트**: 80번
- **보안**: 평문 전송으로 암호화 없음
- **위험성**: 패킷 감청 시 제3자가 정보 확인 가능

### HTTPS (HTTP Secure)

- **개념**: HTTP + SSL/TLS 암호화
- **기본 포트**: 443번
- **보안**: 데이터 암호화로 패킷 감청 시에도 정보 보호
- **신뢰성**: 서버 인증을 통한 신뢰할 수 있는 서버 판별 가능

---

## SSL/TLS 프로토콜 이해

### SSL vs TLS

- **SSL (Secure Sockets Layer)**
    - 1990년대 후반 등장
    - 여러 알려진 취약점으로 현재 사용 중단
    - 역사적 의미로만 남아있음

- **TLS (Transport Layer Security)**
    - SSL의 대안으로 등장
    - 현재 실제로 사용되는 프로토콜
    - SSL과 혼용하여 부르지만 실제로는 TLS 사용



### SSL/TLS의 위치

```
OSI 7계층 구조에서의 위치:
┌─────────────────┐
│  7. 응용 계층    │ ← HTTP
├─────────────────┤
│  6. 표현 계층    │ ← SSL/TLS (암호화)
├─────────────────┤
│  5. 세션 계층    │
├─────────────────┤
│  4. 전송 계층    │ ← TCP
├─────────────────┤
│  3. 네트워크 계층 │
└─────────────────┘
```



## 암호화 방식의 이해

### 대칭키 암호화

**개념**: 동일한 키로 암호화와 복호화 수행

**장점**:

- 빠른 처리 속도
- 적은 연산 자원 사용

**단점**:

- 키 교환 문제 (키 전달 시 유출 위험)
- 키 관리의 복잡성

**사용 예시**:

```
원본 데이터: "Hello World"
대칭키: "secretkey123"
암호화: encrypt("Hello World", "secretkey123") → "X9$mK2@pL"
복호화: decrypt("X9$mK2@pL", "secretkey123") → "Hello World"
```

### 공개키(비대칭키) 암호화

**개념**: 공개키와 비밀키 한 쌍을 사용

**암호화 규칙**:

- 공개키로 암호화 → 비밀키로만 복호화 가능
- 비밀키로 암호화 → 공개키로만 복호화 가능

**장점**:

- 키 교환 문제 해결
- 높은 보안성

**단점**:

- 느린 처리 속도
- 많은 연산 자원 필요

### SSL/TLS의 하이브리드 방식

**핵심 아이디어**: 두 방식의 장점을 결합

1. **공개키 방식**으로 안전하게 대칭키 교환
2. **대칭키 방식**으로 실제 데이터 암호화/복호화



## CA(Certificate Authority)와 SSL 인증서

### CA (인증 기관)

- **역할**: 공인된 기관으로서 SSL 인증서 발급
- **신뢰성**: 브라우저에 사전 등록된 신뢰할 수 있는 기관
- **대표 CA**: Let's Encrypt, DigiCert, GlobalSign 등

### SSL 인증서의 역할

1. **서버 신뢰성 보증**: 접속한 서버가 진짜 해당 도메인의 서버임을 증명
2. **공개키 전달**: 암호화 통신에 사용할 서버의 공개키 제공

### SSL 인증서에 포함된 정보

- CA 정보 (발급 기관)
- 도메인 정보 (인증서가 유효한 도메인)
- 서버의 공개키
- 인증서 유효 기간
- 디지털 서명 (CA의 비밀키로 서명)

### 인증서 검증 과정

```
1. 브라우저가 서버로부터 SSL 인증서 받음
2. 브라우저에 저장된 CA 공개키로 인증서 검증
3. 검증 성공 시 → 신뢰할 수 있는 서버로 판단
4. 인증서에서 서버 공개키 추출하여 사용
```

## SSL/TLS Handshake 상세 과정

### 전제 조건

- TCP 3-way Handshake 완료
- 서버는 미리 CA로부터 SSL 인증서 발급받음

### 0단계: 인증서 발급 (사전 작업)

```
1. 서버 → CA: 도메인 정보 + 서버 공개키 전송
2. CA: CA 비밀키로 정보 암호화하여 인증서 생성
3. CA → 서버: SSL 인증서 전달
```

### 1단계: ClientHello (클라이언트 → 서버)

**목적**: TLS 연결 시작 및 지원 가능한 암호화 방식 알림

**전송 정보**:

- **Cipher Suite 목록**: 지원 가능한 암호화 알고리즘 조합
    
    ```
    예시: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384- ECDHE: 키 교환 알고리즘- RSA: 인증 알고리즘  - AES_256_GCM: 대칭키 암호화- SHA384: 해시 함수
    ```
    
- **Session ID**: 이전 세션 재사용을 위한 식별자
- **TLS 버전**: 지원하는 TLS 프로토콜 버전
- **Client Random**: 32바이트 무작위 값 (나중에 세션키 생성 시 사용)

### 2단계: ServerHello (서버 → 클라이언트)

**목적**: 클라이언트 제안 중 선택 및 서버 정보 전달

**전송 정보**:

- **선택한 Cipher Suite**: 클라이언트 목록에서 서버가 선택한 하나
- **TLS 버전**: 사용할 TLS 프로토콜 버전
- **Server Random**: 32바이트 무작위 값 (세션키 생성용)
- **Session ID**: 세션 재사용을 위한 식별자

### 3단계: Certificate (서버 → 클라이언트)

**목적**: 서버 신뢰성 증명 및 공개키 전달

**과정**:

1. **서버**: CA가 서명한 SSL 인증서 전송
2. **클라이언트**:
    - 브라우저에 저장된 CA 공개키로 인증서 검증
    - 검증 성공 시 서버를 신뢰할 수 있다고 판단
    - 인증서에서 서버 공개키 추출

**보안 검증**:

```
인증서 검증 과정:
1. 인증서를 발급한 CA가 신뢰할 수 있는 CA인지 확인
2. CA 공개키로 인증서 복호화 시도
3. 복호화 성공 → 진짜 CA가 발급한 인증서
4. 도메인 정보가 현재 접속 중인 도메인과 일치하는지 확인
5. 인증서 유효 기간 확인
```

### 4단계: Client Key Exchange (클라이언트 → 서버)

**목적**: 안전한 대칭키 생성을 위한 재료 전달

**과정**:

1. **클라이언트**:
    
    - 48바이트 Pre-master Secret 무작위 생성
    - 서버 공개키로 Pre-master Secret 암호화
    - 암호화된 Pre-master Secret을 서버로 전송
2. **서버**:
    
    - 자신의 비밀키로 수신된 데이터 복호화
    - Pre-master Secret 획득
3. **양쪽 모두**:
    
    ```
    Master Secret 생성:
    Master Secret = PRF(Pre-master Secret, 
                       "master secret", 
                       Client Random + Server Random)
    
    Session Key 생성:
    Client/Server Write Keys = PRF(Master Secret,
                                  "key expansion",
                                  Server Random + Client Random)
    ```
    

### 5단계: ChangeCipherSpec & Finished (양방향)

**목적**: 핸드셰이크 완료 및 암호화 통신 시작

**과정**:

1. **ChangeCipherSpec**:
    - "이제부터 협상된 암호화 방식 사용하겠다" 선언
2. **Finished**:
    - 지금까지의 핸드셰이크 메시지들을 해시하여 무결성 검증
    - 새로 생성된 세션키로 암호화하여 전송
    - 상대방이 올바르게 복호화할 수 있으면 세션키가 정상적으로 생성된 것

## 실제 HTTPS 통신 과정

### 전체 흐름

```
1. TCP 3-way Handshake (연결 설정)
2. TLS Handshake (보안 채널 설정)
3. HTTP 요청/응답 (암호화된 데이터 통신)
4. 연결 종료
```

### 데이터 전송 과정

```
클라이언트 측:
1. HTTP 요청 생성: "GET /api/users HTTP/1.1"
2. 세션키로 암호화: encrypt(request, session_key)
3. 암호화된 데이터 전송

서버 측:
1. 암호화된 데이터 수신
2. 세션키로 복호화: decrypt(data, session_key)
3. HTTP 요청 처리
4. HTTP 응답 생성 후 세션키로 암호화하여 전송
```

## 성능 및 보안 고려사항

### 성능 영향

- **CPU 사용량**: 암호화/복호화 연산으로 인한 추가 부하
- **메모리 사용량**: TLS 상태 정보 저장
- **네트워크 지연**: TLS Handshake로 인한 추가 RTT
- **처리량**: 암호화 오버헤드로 인한 처리량 감소

### 최적화 방법

- **Session Resumption**: 이전 세션 재사용으로 Handshake 생략
- **HTTP/2**: 연결 재사용으로 Handshake 횟수 감소
- **Hardware Acceleration**: 전용 하드웨어로 암호화 가속
- **Certificate Pinning**: 인증서 검증 과정 최적화

### 보안 강화

- **Perfect Forward Secrecy**: 개별 세션키 노출 시에도 다른 세션 보호
- **HSTS**: HTTP 요청을 강제로 HTTPS로 리다이렉트
- **Certificate Transparency**: 인증서 발급 투명성 확보