
> [!NOTE] 자료구조
> [[Heap(힙)]]
[[Tree(트리)]]
[[Graph(그래프)]]
[[Map(맵)]]




> [!help] 어떤 상황에서 힙 자료구조를 사용하는 것이 적합한가요? 대표적인 사용 사례를 함께 설명해주세요.
>힙은 우선순위 큐를 구현하는 데 이상적인 자료구조입니다. 우선순위가 가장 높은 요소에 빠르게 접근해야 하는 상황에서 효율적으로 사용할 수 있습니다. 대표적인 예로 운영체제의 작업 스케줄링이 있습니다. 운영체제는 우선순위가 높은 프로세스를 먼저 실행해야 하므로, 힙을 사용하여 프로세스의 우선순위를 관리하고 가장 높은 우선순위의 프로세스를 O(1) 시간에 찾아 실행할 수 있습니다. 이러한 특성 덕분에 힙은 실시간 시스템이나 자원 관리가 중요한 환경에서 널리 활용됩니다.

> [!help] 인접 행렬과 인접 리스트의 차이점과 각각 어떤 상황에서 유리한가요? 
>인접 행렬은 모든 정점 쌍의 연결 정보를 2차원 배열로 표현하여 O(1)에 간선 존재 여부를 확인할 수 있지만, 희소 그래프에서 메모리를 낭비합니다. 인접 리스트는 각 정점에 연결된 이웃 정점들만 저장하여 메모리 효율성이 높고 모든 이웃을 빠르게 순회할 수 있지만, 특정 간선의 존재 확인에 O(V) 시간이 걸립니다. 밀집 그래프에서는 인접 행렬이, 희소 그래프에서는 인접 리스트가 더 효율적입니다.

> [!help] 맵(Map) 자료구조에 대해 설명해보세요? 
>맵은 키(key)와 값(value)의 쌍으로 데이터를 저장하는 자료구조입니다. 각 키는 맵 내에서 유일하며, 이를 통해 연결된 값에 효율적으로 접근할 수 있습니다. 구현 방식에 따라 해시맵은 해시 함수를 사용해 평균 O(1) 시간에 접근이 가능하고, 트리맵은 레드-블랙 트리 등을 사용해 O(log n) in 시간에 접근하며 키의 순서를 유지합니다.


> [!help] B-tree가 데이터베이스에서 주로 사용되는 이유는?
> B-tree는 디스크 접근 최소화에 최적화되어 있습니다. 데이터베이스는 대용량 데이터를 디스크에 저장하는데, B-tree는 한 노드에 여러 키를 저장함으로써 트리의 높이를 낮게 유지합니다. 이는 디스크 I/O 횟수를 크게 줄여 성능을 향상시킵니다.

> [!help] 정확히 어떻게 디스크 I/O를 줄이는거죠?
> 분기 인자를 크게 구성해서 한 노드당 가지고 있는 key의 개수가 많아지면 높이를 낮게 유지한 채로 관리할 수 있습니다. 레코드를 단 3-4층 높이로 관리한다고 가정하면, 이는 검색 시 디스크 접근 횟수를 3-4회로 제한한다는 의미입니다.
