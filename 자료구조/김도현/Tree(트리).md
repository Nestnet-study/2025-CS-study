
## 1. Tree(트리)

![400](https://i.imgur.com/fcJYuOA.png)




트리는 **노드(node)들**과 이들을 연결하는 **간선(edge)들**로 구성된 계층적 자료구조이다. 각 노드는 부모-자식 관계를 가지며, 사이클이 없는 연결구조를 형성한다. 트리는 데이터를 계층적으로 표현하기에 적합하며, 검색과 정렬에 효율적인 구조를 제공한다.

우리가 사용하는 폴더 구조도 트리라고 할 수 있다.

![](https://i.imgur.com/jx52jHv.png)





##  2. 트리와 그래프의 차이점

트리에 대해 이해하기 위해서는 [[Graph(그래프)]] 와 트리의 차이점을 알아보면서 이해하면 보다 쉽다.
트리는 사실 그래프의 한 종류이다. 특별한 제약조건들을 가진 그래프라고 생각하면 된다.
하지만 설명의 용이성을 생각하여 트리와 그래프는 따로 구분지어서 말하도록 하겠다. 

### 1. **사이클의 유무**
![](https://i.imgur.com/6EeBMwB.png)
사이클이란 한 노드에서 시작하여 다시 그 노드로 돌아오는 경로가 존재하는 것을 말한다. 
위 그래프를 예시로 들어보면, 그래프는 1-2-4-3, 3-4-5, 1-2-4-5-3와 같은 사이클을 가질 수 있다.

하지만 트리는 사이클이 없다. 즉 어떤 노드에서 시작해서 다시 그 노드로 돌아가는 경로는 없다. 



### 2. 연결성의 차이

![](https://i.imgur.com/YWIMXWa.png)

**그래프**의 경우 모든 노드가 연결되어 있지 않은 그래프를 비연결 그래프라고 한다. 그리고 그래프는 두 노드 사이에 여러 경로가 존재할 수 있다.

**트리**는 이와 다르게 **모든 노드는 연결되어**있으며, 임의의 두 노드 사이에는 **정확히 하나의 경로만 존재**한다. 


### 3. **루트 노드 존재 여부**

트리는 항상 하나의 `루트 노드(Root Node)`를 가지고 있다. 루트 노드는 트리의 **최상위에 위치**하며, 모든 노드는 이 루트 노드로부터 접근 가능하다. 루트 노드는 **부모가 없는 유일한 노드**이다.

반면에 그래프는 특별한 시작점이나 루트 노드의 개념이 존재하지 않는다. 그래프에서는 어떤 노드든 시작점이 될 수 있으며, 모든 노드가 동등한 위치에 있다고 볼 수 있다.


### 4. **부모-자식 관계**

트리는 **계층적 구조**를 가지고 있어 명확한 **부모-자식 관계**가 존재한다. 루트 노드를 제외한 모든 노드는 **정확히 하나의 부모 노드**를 가진다. 즉, 각 노드는 여러 자식을 가질 수 있지만, 부모는 오직 하나만 가질 수 있다.

이러한 부모-자식 관계는 트리의 **방향성**을 결정짓는 중요한 특성이라 할 수 있다. 데이터는 항상 `부모에서 자식으로` 흐르며, 이는 트리가 자연스럽게 계층 구조를 표현할 수 있게 한다.

예를 들어, 파일 시스템에서 폴더(부모)는 여러 파일이나 하위 폴더(자식)를 포함할 수 있지만, 각 파일이나 하위 폴더는 오직 하나의 상위 폴더에만 속한다.

반면, 그래프에서는 노드 간의 관계가 **동등**하며, 특별한 부모-자식 개념이 없다. 노드들은 서로 연결되어 있을 뿐, 계층적 관계를 갖지 않는다.



## 3. 트리의 종류 


## 1. 이진 트리(Binary Tree)

이진 트리는 각 노드가 **최대 2개의 자식 노드**만 가질 수 있는 특별한 형태의 트리이다. 각 노드는 **왼쪽 자식**과 **오른쪽 자식**으로 구분되며, 자식이 없는 경우도 가능하다. 이진 트리는 단순하면서도 강력한 자료구조로, 컴퓨터 과학의 다양한 영역에서 활용된다.

이진트리는 그 구조적 특성에 따라 여러 유형으로 분류를 할 수 있다.

![](https://i.imgur.com/TVZAmmP.png)
**완전이진 트리**는 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며, 마자막 레벨의 노드들은 가능한 **왼쪽부터 채워져 있는** 트리이다. `힙(Heap)` 자료구조는 완전 이진 트리를 기반으로 구현된다. 완전 이진 트리는 **배열을 사용하여 효율적으로 구현**할 수 있어 메모리 관리에 유리하고, 노드의 인덱스를 기반으로 부모-자식 관계를 쉽게 계산할 수 있다. 예를들어 루트노드를 제외하고 어떤 노드의 `2*index +1` 의 값의 경우 왼쪽 자식을 구할 수 있고,`2*index +2` 를 통해 오른쪽 자식을 구할 수 있다.


**포화 이진 트리**는 모든 노드가 **0개 또는 2개의 자식 노드**를 가지는 트리이다. 즉, 어떤 노드도 정확히 1개의 자식 노드만 가지지 않는다.

**완전 포화 이진 트리**는 모든 내부 노드가 정확히 **두 개의 자식**을 가지며, **모든 리프 노드가 같은 레벨**에 있는 트리이다. 이는 가장 균형 잡힌 형태의 이진 트리로, 높이가 `h`인 완전 포화 이진 트리는 정확히 `2^(h+1)-1`개의 노드를 가진다.

이처럼 이진 트리는 그 구조적 특성에 따라 다양한 유형으로 분류할 수 있다. 각 유형은 특정 상황에서 최적의 성능을 발휘하므로, **문제 해결에 적합한 이진 트리 유형을 선택하는 것이 중요**하다. 이 외에도 비포화 이진 트리, 균형 이진 트리 등 다양한 종류가 있지만, 이 글에서는 기본적인 유형만 다루었다.

## 2. 이진 탐색 트리(Binary Search Tree, BST)

![400](https://i.imgur.com/O4a5aoJ.png)

이진 탐색 트리는 이진 트리에 **특별한 규칙**을 추가한 형태이다. 가장 중요한 특성은 모든 노드에 대해 **왼쪽 자식 노드의 값은 부모 노드보다 작고**, **오른쪽 자식 노드의 값은 부모 노드보다 크다**는 것이다. 이 속성은 트리의 모든 서브트리에도 동일하게 적용된다. 
위 사진을 예시로 보면, 이러한 구조 덕분에 이진 탐색 트리는 검색, 삽입, 삭제 연산을 매우 효율적으로 수행할 수 있으며, 평균적으로 `O(log n)`의 시간 복잡도를 가진다. **정렬된 데이터**를 다루는데 적합하며, 사전이나 심볼 테이블과 같은 응용 프로그램에서 자주 사용된다.

## 3. 균형 트리(Balanced Tree)

균형 트리는 트리의 **높이를 최소화**하여 검색 효율성을 극대화한 트리 구조이다. 일반적인 이진 탐색 트리는 데이터가 이미 정렬된 순서로 삽입될 경우 **한쪽으로 치우치는 현상**이 발생하여 성능이 저하될 수 있다. 이를 해결하기 위해 여러 종류의 균형 트리가 개발되었다.

### 1. AVL 트리

![](https://i.imgur.com/JeuGCCv.png)

AVL 트리는 균형 트리의 대표적인 예로, 모든 노드에서 **왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1**을 넘지 않도록 유지한다. 이 차이를 '**균형 인수(balance factor)**'라고 부른다. 균형 인수는 노드의 왼쪽 서브트리 높이에서 오른쪽 서브트리 높이를 뺀 값으로 계산한다.

AVL 트리는 삽입이나 삭제 후에 균형이 깨질 경우 **회전 연산**을 통해 균형을 복원한다. 회전 연산에는 네 가지 경우가 있다.

1. **LL 회전**(왼쪽-왼쪽 경우): 오른쪽으로 한 번 회전한다.
2. **RR 회전**(오른쪽-오른쪽 경우): 왼쪽으로 한 번 회전한다.
3. **LR 회전**(왼쪽-오른쪽 경우): 왼쪽 자식을 왼쪽으로 회전한 후, 루트를 오른쪽으로 회전한다.
4. **RL 회전**(오른쪽-왼쪽 경우): 오른쪽 자식을 오른쪽으로 회전한 후, 루트를 왼쪽으로 회전한다.


예를 들어, 위 사진 AVL 트리에 노드 **7**을 삽입한다고 가정해보자. 노드 7은 노드 9의 왼쪽 자식으로 삽입될 것이다. 이렇게 되면 노드 12에서 균형이 깨지게 된다(왼쪽 서브트리 높이가 2, 오른쪽 서브트리 높이가 0). 이 경우 **LL 회전**이 필요하다.

```text
	12          9
   /  \        / \
  9   14  →   7  12
 /             /  \
7            (빈)  14
```

회전 후 노드 9가 새로운 루트가 되고, 노드 12는 오른쪽 자식이 된다. 이로써 균형이 복원된다.

이러한 회전 연산을 통해 AVL 트리는 항상 균형을 유지하며, 검색, 삽입, 삭제 모두 **O(log n) 시간 복잡도**를 보장한다.

이러한 회전 연산을 통해 AVL 트리는 항상 균형을 유지하며, 검색, 삽입, 삭제 모두 **O(log n) 시간 복잡도**를 보장한다.

### 2. Red-Black 트리
![](https://i.imgur.com/w1oVjfx.png)


Red-Black 트리는 각 노드에 **색상 정보**를 추가하여 균형을 유지하는 방식이다. 모든 노드는 빨간색 또는 검은색으로 표시되며, 다음 규칙을 따른다.

1. 모든 노드는 **빨간색 또는 검은색**이다.
2. **루트 노드**는 항상 **검은색**이다.
3. 모든 **리프 노드(NIL)**는 **검은색**이다.
4. **빨간색 노드**의 자식은 항상 **검은색**이다(즉, 빨간색 노드가 연속으로 나올 수 없다).
5. 루트에서 모든 리프 노드까지의 경로에는 **동일한 수의 검은색 노드**가 있다.

Red-Black 트리는 삽입이나 삭제 후 균형이 깨질 경우, **노드 색상 변경**과 **회전 연산**을 적절히 조합하여 균형을 복원한다. AVL 트리에 비해 Red-Black 트리는 삽입과 삭제 시 회전 횟수가 적어 실제 구현에서 더 효율적인 경우가 많다.

위 사진의 Red-Black 트리에 노드 **10**을 삽입한다고 가정해보자. 노드 10은 노드 11의 왼쪽 자식으로 삽입되고 빨간색으로 설정된다.

AVL 트리와의 주요 차이점은 AVL 트리가 더 엄격한 균형 조건을 가진다는 점이다. AVL 트리는 높이 차이가 최대 1까지만 허용되지만, Red-Black 트리는 최악의 경우 한쪽 경로가 다른 쪽의 두 배까지 길어질 수 있다. 따라서 **AVL 트리는 검색에 더 최적화**되어 있고, **Red-Black 트리는 삽입/삭제에 더 효율적**이다.



### 3. B-트리
![](https://i.imgur.com/TGRNZCC.png)




B-트리는 이진 트리의 개념을 확장하여 **한 노드가 여러 개의 키와 자식**을 가질 수 있게 한 균형 트리이다. B-트리의 차수가 `m`일 때, 각 노드는 다음 특성을 가진다.

1. 루트를 제외한 모든 노드는 최소 `⌈m/2⌉-1`개에서 최대 `m-1`개의 키를 가진다.
2. 루트 노드는 1개 이상 `m-1`개 이하의 키를 가진다.
3. 리프 노드가 아닌 노드의 자식 수는 키의 수보다 항상 1 많다.
4. 모든 리프 노드는 같은 레벨에 있다.

 노드 하나가 디스크 블록이나 페이지에 해당하며, 각 노드에 많은 키를 저장함으로써 **디스크 I/O 작업을 최소화**한다. 또한 B-트리는 삽입, 삭제, 검색 모두 **O(log n) 시간 복잡도**를 보장한다.
 

![](https://i.imgur.com/SwtzFEV.png)

위 사진의 B-트리에 노드 **15**를 삽입한다고 가정해보자. 노드 15는 중간 노드 [9, 12]와 [18, 21] 사이에 위치해야 한다:

```text
		[7, 16]                  [7, 16]
      /    |   \               /    |   \
[1,2,5,6] [9,12] [18,21]  →  [1,2,5,6] [9,12,15] [18,21]
```

하지만 만약 노드가 가득 차서 더 이상 키를 삽입할 수 없다면, 노드 분할(split)이 발생한다. 예를 들어, [9, 12] 노드가 이미 최대 허용 키 수에 도달했다면:

```text
		[7, 16]                     [7, 12, 16]
      /    |   \                  /    |    \   \
[1,2,5,6] [9,12] [18,21]  →  [1,2,5,6] [9] [15] [18,21]
```

중간 키(12)가 부모 노드로 올라가고, 나머지 키들이 분할된다.

B-트리는 **디스크 기반 저장 시스템**에 특히 효율적이다. 데이터베이스나 파일 시스템에서는**메모리에서 디스크로의 접근이 매우 비용이 크기 때문에**, **한 번의 디스크 접근으로 많은 양의 데이터를 읽거나 쓰는 것이 중요**하다. B-트리는 각 노드에 많은 키를 저장할 수 있어 디스크 I/O 횟수를 최소화할 수 있다. 또한 B-트리는 항상 균형을 유지하여 검색, 삽입, 삭제 모두 로그 시간 복잡도를 가지므로 대용량 데이터베이스 시스템에 이상적이다.