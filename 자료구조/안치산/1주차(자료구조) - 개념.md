##### 스택
- LIFO (Last In Last Out)

##### 큐
- FIFO (First In First Out)

##### linked list
- 각 노드가 데이터와 다음 노드를 가리키는 포인터를 포함하는 형태로 연결된 선형 자료구조
- 배열과의 차이점
	- 장점
		- 위치만 알고있다면 모든 데이터의 삽입, 삭제가 `O(1)`에 가능함
	- 단점
		- 메모리 접근 속도 저하
			- 비연속적인 메모리 공간에 데이터가 존재해서 CPU 캐시를 효과적으로 사용할 수 없음
		- GC 부담 증가
			- 각 노드가 별도의 객체로 할당됨으로써 GC에서 추적해야 하는 대상 증가
- ex) LRU (Least Recently Used) Cache
	- 최근에 사용된 데이터를 앞으로 보내야 하는데 만약 배열로 구현되게 된다면 시간복잡도가 O(n)이라 병목이 발생하게 됨
		- 일부 고성능 캐시에서는 순환 배열 + 인덱스 맵으로 구현하기도 함

- 큐나 스택을 구현할때 데이터를 삽입/삭제하면서 앞쪽 데이터가 사용되지 않고 남게되는데 이를 해결하기 위해서 환형 버퍼 형태로 구현함
	- 배열의 끝과 시작을 연결해서 만약 앞쪽 공간이 비어있으면 해당 공간을 사용

- [?] 텍스트 에디터의 경우 텍스트 사이사이를 이동해야하는데 어떻게 구현될까?
	- 대표적인 방식이 GapBuffer
		- 커서 위치에 여유 공간(갭)을 둔 배열 구조 (`[앞부분][gap][뒷부분]` 형태로 저장)
		- 대부분 사용자는 앞에서부터 연속적인 타이핑을 함.
		- 중간 삽입/삭제는 드물게 일어나므로, 갭 이동 비용도 드물게 발생.
		- 일반적인 타이핑 패턴에 매우 잘 맞는 구조.
	- 대용량 문서에서는 다른 구조 사용
		- Rope: 문자열을 트리 구조로 나누어 저장
		- Piece Table: 텍스트를 수정하지 않고, 원본 버퍼 + 추가 버퍼 + 조각 테이블로 관리

##### 동적배열
- C++의 vector
- 크기를 지수 형태로 늘려감으로써 기존 정적배열의 한계를 보완
	- 이론적으로 메모리 할당의 시간복잡도가 O(1) $$1+2+4+8+16+...+2^n = 2^{n+1} - 1$$
##### 트리
- 계층적으로 데이터를 구성하는 자료구조 (부모-자식 관계)
- 삽입, 삭제, 조회가 모두 O(lg n)에 가능함
- 트리의 높이가 성능에 많은 영향을 미침
	- 이를 위해 AVL, Red-Black트리, 트립, B-Tree 등의 다양한 구현방식이 존재함

- 이진트리 vs 다진트리
	- 이진트리는 노드 하나의 크기가 작기 때문에 CPU 캐시에 유리 -> 메모리 기반 탐색 시스템에 적합
		- ex) Java의 TreeMap: Red-Black Tree
	- 다진 트리로써 노드 하나의 크기가 큰 대신 트리의 높이가 낮기 때문에 디스크 I/O 횟수 최소화 -> 디스크 기반 대용량 탐색에 적합
		- ex) MySQL InnoDB의 index: B+Tree

- AVL vs Red-Black
	- 이진 탐색 트리 기반의 균형 트리
		- 트리의 높이를 균일하게 유지하기 위해서 삽입/삭제시 별도의 처리가 추가
	- AVL
		- 트리의 높이를 기준으로 처리되기 때문에 삽입/삭제시 오버헤드가 더 클 수 있지만, 그만큼 트리의 높이가 항상 균일하기 때문에 최적의 읽기 성능이 보장됨
	- RedBlack
		- 색상 개념을 도입함으로써 삽입/삭제시 오버헤드를 줄이는 방법. 그만큼 트리의 높이의 균일함이 AVL에 비해서 완벽하게 보장되지 않음
		- 자바, C++ 트리의 구현체

##### 힙
- 가장 큰 원소를 찾는데 최적화된 형태의 이진 트리
- 제약 조건이 BST보다 간단함
	- 부모 노드의 값이 자식 노드의 값보다 크기만 하면 된다
- 제약 조건을 단순화함으로써 얻는 장점
	1. 배열로 간단하게 구현이 가능함 (CPU 캐싱에 유리)
		- 부모 노드가 `arr[i]`에 위치한다면 자식노드는 `arr[i*2+1]`, `arr[i*2+2]`
	2. 간단한 규칙으로 트리의 높이를 균일하게 유지할 수 있음
		- 항상 배열의 맨 마지막에 원소를 추가하고 부모 원소와 재귀적으로 대소관계를 비교하며 교체
- [?] 다진 트리도 힙처럼 구현이 가능할까
	- 실제로 사용됨
	- 삽입 성능은 더 좋지만 삭제 성능이 안 좋아짐
		- 트리의 높이가 줄어드는 대신 삭제시 검토해야하는 자식의 수가 증가
##### 트립
- 트리 + 힙
- PS에서 RedBlack 트리와 같은 개념을 구현하기는 시간이 걸리기 때문에 보다 단순한 구조로 빠르게 균형 잡힌 이진 트리를 구현하기 위해 사용하는 방식
- 우선순위를 이용해서 확률적으로 균형을 유지함으로써 평균적으로 트리의 높이가 O(log N)

일반적으로 Map의 구현체는 Tree 또는 Hash Table 형태로 나뉜다
##### hash table
- 데이터를 특정 규칙(hash function)에 따라 계산한 해시값을 기반으로 배열 인덱스에 매핑하여 저장하는 자료구조
- 해시값을 기반으로 데이터에 접근하기 때문에 조회, 수정, 삭제가 O(1)에 가능
- 하지만 여러개의 데이터에 대해서 동일한 해시값이 생성된다면, 즉 충돌이 발생한다면 충돌이 발생된 데이터를 linked list, tree 등 추가적으로 관리를 해줘야해서 여기서 병목이 발생할 수 있음
	- hash function이 가능한 한 충돌이 적고, 고르게 분포된 값을 만들어야 함
##### 그래프
- 객체들의 상호관계를 표현하기 위해 고안된 자료구조
	- 트리또한 그래프의 일부
- 구현방식
	- 인접 행렬
	- 인접 리스트
		- [!] linked list로 구현해서 인접 리스트가 아님
		- 정점별로 연결된 간선을 저장
- 노드 탐색 방법
	- DFS(Depth First Search)
	- BFS(Breadth First Search)
- 간선에 가중치가 존재하는지, 간선에 방향이 존재하는지에 따라 다양한 유형으로 세분화됨

- DAG
	- Directed Acyclic Graph
	- 방향 비순환 그래프
	- 위상정렬
		- 구현방식
			- BFS를 이용해서 진입차수가 0인 정점들을 우선 탐색
			- DFS를 이용해서 탐색이 완료된 노드부터 스택에 넣고 역순으로 출력
		- 그래프에 사이클이 존재하는지 여부를 판단하는 것도 가능
			- BFS 방식: 정렬된 노드 수와 전체 노드 수 비교
			- DFS 방식: 탐색 중인 노드를 다시 만나는 경우

- 간선에 가중치가 존재할때 최단경로를 구하는 알고리즘
	- 다익스트라
		- 단일 출발점에서 모든 정점까지의 최단거리
		- 출발점에서 가장 가까운 정점부터 차례대로 방문하는 방식
		- 가중치가 낮은 간선부터 차례대로 방문하고 이미 방문한 노드를 다시 방문하지 않음
			- 귀류법으로 증명한다면
				- 만약 A에서 B까지의 거리가 최소일때 해당 거리가 최적의 거리가 아닐 경우 A->C->B거리가 더 최소여야하는데 이미 A->C의 거리가 A->B 거리보다 큰 상황이므로 모순
			- 가중치에 음수가 있는 경우 해당 증명이 성립하지 않는다
		- 시간복잡도 `O((V+E)*lgE)`

	- 벨만-포드 알고리즘
		- 단일 출발점에서 모든 정점까지의 최단거리
		- 음의 가중치 간선이 있는 경우에도 최단거리를 구할 수 있음
		- 정점이 V개일 때, 사이클 없는 경로는 최대 V - 1개의 간선으로 구성되는 특징을 이용
			- 이러한 특징을 이용해 음의 사이클이 없는지 판별하는 것까지 가능
		- 시간복잡도 `O(V*E)`
	- 플로이드-워셜 알고리즘
		- 모든 정점간의 최단 거리
		- 시간복잡도 `O(V^3)`
		- 메모리를 많이 잡아먹지만 대부분의 경우 E > V이기 때문에 실행시간 측면에서 벨만포드보다 유리함
			- 음의 가중치가 없다면 다익스트라를 n번 돌리는게 나음
- DSU (Disjoint Set Union)
	- 상호배타적집합
	- 겹치지 않는 집합을 나타내는 자료구조

- MST 트리
	- 

---

### TODO
##### 트리
- 상호 배타적 집합
- 트라이
- 구간 트리
- 펜윅 트리
- 최소 스패닝 트리
	- 크루스칼
	- 프림
##### 그래프
- 유니온 파인드

