# 1. CPU 레지스터
---



![](https://i.imgur.com/hSHJm8O.png)


**레지스터**는 CPU 내부의 **작은 임시 저장 장치**이다.
프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장.



## 레지스터의 종류

### 1. 프로그램 카운터(PC) 레지스터 :

- 다음에 실행될 명령어의 주소를 저장.
- CPU가 명령을 실행할 떄 마다, PC는 자동으로 다음 명령어의 위치를 가리키며, 프로그램의 실행 순서를 제어하는데 중요한 역할

### 2. 명령 레지스터(Instruction Register):

- 현재 실행 중인 명령어를 저장
- CPU는 IR에 저장된 명령어 해석 및 실행

### 3. 메모리 주소 레지스터(MAR):

- 메모리의 특정 주소를 저장
- CPU가 메모리에 데이터를 읽거나 쓸 때, MAR은 해당 데이터의 위치를 가리키는 주소를 저장

### 4. 메모리 버퍼 레지스터(MBR):

- 메모리와 CPU 사이에서 데이터 중개
- MBR은 메모리에서 읽은 데이터 및 메모리에 쓸 데이터를 임시 보관

### 5. 플래그 레지스터 (Flag Register):

- 상태 레지스터는 CPU의 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장

### 6. 범용 레지스터 (General-Purpose Registers):

- 다 할 수 있는 놈
- MAR은 메모리 주소값만, MBR은 데이터 버스로 주고 받은 값만 저장하지만 범용레지스터는 데이터와 주소를 모두 저장할 수 있다.

### 7. 스택 포인터:

- 스택이라는 메모리 영역을 관리
 ![](https://i.imgur.com/jkFOAwr.png)


### 8. 베이스 레지스터 (Base Registers):

- 메모리 관리에 사용
- 메모리 세그먼트의 시작 주소를 저장하고, 한계 레지스터는 세그먼트의 크기를 저장

#### 세그먼트란?

세그먼트는 메모리를 논리적으로 분할한 단위입니다. 쉽게 말해 프로그램의 서로 다른 부분들(코드, 데이터, 스택 등)을 구분하여 메모리에 저장하는 방식입니다.

#### 세그먼트의 종류 (일반적인 예)

1. **코드 세그먼트**: 프로그램의 실행 코드가 저장됨
2. **데이터 세그먼트**: 전역 변수와 정적 변수가 저장됨
3. **스택 세그먼트**: 함수 호출 정보, 지역 변수가 저장됨
4. **힙 세그먼트**: 동적으로 할당된 메모리가 저장됨




# 2. 프로그램 실행 과정
---

![](https://i.imgur.com/206gY0w.png)


① PC에 저장된 주소를 MAR로 보낸다.  
② MAR에 저장된 주소에 있는 기억장치의 명령어를 MBR로 읽어 오고, PC를 증가시킨다. 명령어의 실행을 위해 읽어 온 명령을 IR에 저장한다.  
③ 명령어의 연산코드는 명령어 해독기로 보내고 오퍼랜드는 주소처리기로 보낸다.  
④ 주소처리기는 MAR을 통해 기억장치에 접근하여 명령어 수행에 필요한 오퍼랜드의 주소 또는 다음 명령어의 주소를 계산한다.  
⑤ 제어신호 발생기에서는 위의 ①~④ 과정에서 필요한 제어신호와 연산코드를 해독하여 명령 수행을 위한 제어신호를 발생시킨다. 이때 명령어가 기억장치의 주소를 참조하는 명령어라면 주소처리기를 동작시켜 다음에 수행될 명령어의 주소를 계산한다.  
⑥ 현재 IR에 있는 명령어의 수행이 끝나면 증가된 PC의 내용은 다음에 수행할 명령어의 주소를 지정하거나 분기가 필요한 경우 해당 명령어의 주소를 지정하는데 이는 다시 ①부터의 과정을 반복하며 실행된다.





CPU 가 실행하고자 하는 프로그램이 메모리에 1000번지부터 1500번지까지 저장되어 있다.  
이제 프로그램이 1000번지 , 즉 처음부터 실행한다고 가정하면

1. ![](https://velog.velcdn.com/images/kong2520/post/44864406-6a8f-44e4-a30c-9da048101b1e/image.png)

- PC 에는 1000 번지 (실행될 명령어의 메모리주소) 가 저장된다.

2. ![](https://velog.velcdn.com/images/kong2520/post/9e1a5138-48ef-4dd3-9ede-b34b2c70bdfa/image.png)

- MAR(메모리 주소 레지스터)에 PC(프로그램카운터)에 저장된 메모리 주소를 복사한다.

3. ![](https://velog.velcdn.com/images/kong2520/post/c872e94f-c834-4271-94f7-3d6a923abf3f/image.png)

- 제어장치가 메모리 읽기 제어신호를 내보내 MAR(메모리 주소 레지스터)가 저장하고 있는 주소에 담긴 명령어을 읽어오라는 신호를 보낸다.

4. ![](https://velog.velcdn.com/images/kong2520/post/1e1578df-671d-448f-8b73-06c2b6895e69/image.png)

- 그렇게 되면 메모리는 1000번지에 저장된 "1101" 명령어를 데이터 버스를 통해 MBR(메모리 버퍼 레지스터) 에 명령어를 전달해주게 된다.
- 메모리 버퍼 레지스터에 메모리 주소 레지스터가 담고 있는 주소에 대한 명령어가 전달되면 PC(프로그램 카운터) 다음 실행할 메모리 주소로 업데이트 된다. 즉 프로그램 카운터가 +1 증가 되었다 (중요)

5. ![](https://velog.velcdn.com/images/kong2520/post/f6b3b187-0815-438d-aa49-2e12a47b3c59/image.png)

- 제어장치가 명령어를 해석하기 위해 MBR(데이터 버퍼 레지스터)에 있던 명령어를 IR(명령어 레지스터)로 전달한다.



참고: https://velog.io/@kong2520/CPU-%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1-2-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8 




# 질문 
---

1. PC도 명령어 주소 저장(다음), MAR도 명령어 주소 저장 (현재) 두개의 레지스터를 통합하면 안될까? ex) MAR 없고, PC만 사용 / PC없고, MAR만 사용
   

2. 명령어 실행과정에서 MAR(메모리 주소 레지스터)에 PC(프로그램카운터)에 저장된 메모리 주소를 복사하고, 제어장치가 메모리 읽기 제어신호를 통해 MAR에 있는 주소를 메모리에서 명령어를 읽어오고, 해당 명령어를 MBR에 저장한다. 
   ==메모리 버퍼 레지스터에 메모리 주소 레지스터가 담고 있는 주소에 대한 명령어가 전달되면 PC(프로그램 카운터) 다음 실행할 메모리 주소로 업데이트 된다.== 
   이후, 제어장치가 명령어를 해석하기 위해 MBR에 있는 명령어를 IR로 전달하는데, 
   
   **왜 하필 PC카운트 증가가 저 타이밍에 이루어져야할까?**
   **다른 때에 PC 카운트 증가가 이루어지면 안될까?**
   
