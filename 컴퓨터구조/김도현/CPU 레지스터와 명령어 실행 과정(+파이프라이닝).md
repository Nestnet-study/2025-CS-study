# 1. CPU 레지스터
---



![](https://i.imgur.com/hSHJm8O.png)


**레지스터**는 CPU 내부의 **작은 임시 저장 장치**이다.
프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장.



## 레지스터의 종류

### 1. 프로그램 카운터(PC) 레지스터 :

- 다음에 실행될 명령어의 주소를 저장.
- CPU가 명령을 실행할 떄 마다, PC는 자동으로 다음 명령어의 위치를 가리키며, 프로그램의 실행 순서를 제어하는데 중요한 역할

### 2. 명령 레지스터(Instruction Register):

- 현재 실행 중인 명령어를 저장
- CPU는 IR에 저장된 명령어 해석 및 실행

### 3. 메모리 주소 레지스터(MAR):

- 메모리의 특정 주소를 저장
- CPU가 메모리에 데이터를 읽거나 쓸 때, MAR은 해당 데이터의 위치를 가리키는 주소를 저장

### 4. 메모리 버퍼 레지스터(MBR):

- 메모리와 CPU 사이에서 데이터 중개
- MBR은 메모리에서 읽은 데이터 및 메모리에 쓸 데이터를 임시 보관

### 5. 플래그 레지스터 (Flag Register):

- 상태 레지스터는 CPU의 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장

### 6. 범용 레지스터 (General-Purpose Registers):

- 다 할 수 있는 놈
- MAR은 메모리 주소값만, MBR은 데이터 버스로 주고 받은 값만 저장하지만 범용레지스터는 데이터와 주소를 모두 저장할 수 있다.

### 7. 스택 포인터:

- 스택이라는 메모리 영역을 관리
 ![](https://i.imgur.com/jkFOAwr.png)


### 8. 베이스 레지스터 (Base Registers):

- 메모리 관리에 사용
- 메모리 세그먼트의 시작 주소를 저장하고, 한계 레지스터는 세그먼트의 크기를 저장

#### 세그먼트란?

세그먼트는 메모리를 논리적으로 분할한 단위입니다. 쉽게 말해 프로그램의 서로 다른 부분들(코드, 데이터, 스택 등)을 구분하여 메모리에 저장하는 방식입니다.

#### 세그먼트의 종류 (일반적인 예)

1. **코드 세그먼트**: 프로그램의 실행 코드가 저장됨
2. **데이터 세그먼트**: 전역 변수와 정적 변수가 저장됨
3. **스택 세그먼트**: 함수 호출 정보, 지역 변수가 저장됨
4. **힙 세그먼트**: 동적으로 할당된 메모리가 저장됨




# 2. 프로그램 실행 과정
---

![](https://i.imgur.com/206gY0w.png)


① PC에 저장된 주소를 MAR로 보낸다.  
② MAR에 저장된 주소에 있는 기억장치의 명령어를 MBR로 읽어 오고, PC를 증가시킨다. 명령어의 실행을 위해 읽어 온 명령을 IR에 저장한다.  
③ 명령어의 연산코드는 명령어 해독기로 보내고 오퍼랜드는 주소처리기로 보낸다.  
④ 주소처리기는 MAR을 통해 기억장치에 접근하여 명령어 수행에 필요한 오퍼랜드의 주소 또는 다음 명령어의 주소를 계산한다.  
⑤ 제어신호 발생기에서는 위의 ①~④ 과정에서 필요한 제어신호와 연산코드를 해독하여 명령 수행을 위한 제어신호를 발생시킨다. 이때 명령어가 기억장치의 주소를 참조하는 명령어라면 주소처리기를 동작시켜 다음에 수행될 명령어의 주소를 계산한다.  
⑥ 현재 IR에 있는 명령어의 수행이 끝나면 증가된 PC의 내용은 다음에 수행할 명령어의 주소를 지정하거나 분기가 필요한 경우 해당 명령어의 주소를 지정하는데 이는 다시 ①부터의 과정을 반복하며 실행된다.





CPU 가 실행하고자 하는 프로그램이 메모리에 1000번지부터 1500번지까지 저장되어 있다.  
이제 프로그램이 1000번지 , 즉 처음부터 실행한다고 가정하면

1. ![](https://velog.velcdn.com/images/kong2520/post/44864406-6a8f-44e4-a30c-9da048101b1e/image.png)

- PC 에는 1000 번지 (실행될 명령어의 메모리주소) 가 저장된다.

2. ![](https://velog.velcdn.com/images/kong2520/post/9e1a5138-48ef-4dd3-9ede-b34b2c70bdfa/image.png)

- MAR(메모리 주소 레지스터)에 PC(프로그램카운터)에 저장된 메모리 주소를 복사한다.

3. ![](https://velog.velcdn.com/images/kong2520/post/c872e94f-c834-4271-94f7-3d6a923abf3f/image.png)

- 제어장치가 메모리 읽기 제어신호를 내보내 MAR(메모리 주소 레지스터)가 저장하고 있는 주소에 담긴 명령어을 읽어오라는 신호를 보낸다.

4. ![](https://velog.velcdn.com/images/kong2520/post/1e1578df-671d-448f-8b73-06c2b6895e69/image.png)

- 그렇게 되면 메모리는 1000번지에 저장된 "1101" 명령어를 데이터 버스를 통해 MBR(메모리 버퍼 레지스터) 에 명령어를 전달해주게 된다.
- 메모리 버퍼 레지스터에 메모리 주소 레지스터가 담고 있는 주소에 대한 명령어가 전달되면 PC(프로그램 카운터) 다음 실행할 메모리 주소로 업데이트 된다. 즉 프로그램 카운터가 +1 증가 되었다 (중요)

5. ![](https://velog.velcdn.com/images/kong2520/post/f6b3b187-0815-438d-aa49-2e12a47b3c59/image.png)

- 제어장치가 명령어를 해석하기 위해 MBR(데이터 버퍼 레지스터)에 있던 명령어를 IR(명령어 레지스터)로 전달한다.



참고: https://velog.io/@kong2520/CPU-%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1-2-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8 




# 파이프라이닝


### 명령어 파이프라닝이란? 
간단하게 CPU가 시간을 알뜰하게 사용해 명령어를 처리하는 방법


명령어가 처리되는 과정을 비슷한 시간 간격으로 나누면 다음과 같다.
1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과저장

![](https://i.imgur.com/XveMKDw.png)





### 파이프라인 사용 이유는?
파이프라인을 사용하지 않고 단일 사이클 (single cycle)을 사용하면 한 명령어가 끝날 때까지 다른 명령어를 실행하지 못하게 된다. 
아래 사진처럼 같은 명령어를 실행하더라도 동작 시간이 매우 길어지는 것이다. 
![](https://i.imgur.com/YKHS8OI.png)



### 파이프라인 해저드(Pipeline Hazard)


```mermaid
graph TD
    A[파이프라인 위험] --> B[데이터 위험]
    A[파이프라인 위험] --> C[제어 위험]
    A[파이프라인 위험] --> D[구조적 위험]
```


1. 구조적 해저드
   - 하드웨어가 여러 명령들의 수행을 지원하지 않기 때문에 발생, 자원충돌(Resource Conflicts)
2. 데이터 해저드
	- 명령어 간의 의존성에 의해 발생
	- RAW, WAR, WAW 해저드가 존재
3. 제어 해저드
	- 분기(jump나 brunch 등) 명령어에 의해서 발생
	- 분기를 결정하는 시점에 잘못된 명령어 파이프라인에 있을 경우



- **구조적 해저드**
 ![](https://i.imgur.com/AUyuS4q.png)
CC에서 Load명령어와 Instruction 3 명령어가 한순에 메모리를 동시에 사용해 충돌현상이 발생



- **데이터 해저드**
![](https://i.imgur.com/oBmxdk0.png)

데이터 해저드의 종류로 RAW(Read After Write), WAR(Write After Read), WAW(Write After Write).



| 구분     | 설명                                                      | 비고               |
| ------ | ------------------------------------------------------- | ---------------- |
| 전방전달   | 레지스터 파일에 반영되기 전에 수행(EX) 단계에서 계산된 결과를 다음 인스트럭션의 수행단계로 전달 | H/W 추가 필요        |
| 지연     | 컴파일러 수준에서 해저드 발견, NOP 명령어 삽입                            | nop 명령어 삽입       |
| 비순차 실행 | 접근 중인 데이터와 관련없는 명령어를 삽입                                 | 컴파일러 수준 코드 실행 변경 |
| 프로그래밍  | 변수를 늘리거나, 계산이 완료된 후 한번에 실행                              | 레지스터를 고려해서 프로그래밍 |




-  **제어 해저드** 
![](https://i.imgur.com/FzQAkdj.png)

제어 해저드는 분기가 결정된 시점에 수행되지 않을 명령어가 파이프라인에 존재할 때 발생

|구분|설명|비고|
|---|---|---|
|분기예측|명령이 분기하는지 미리 예측|정적 예측, 동적 예측|
|브랜치 지연|컴파일러가 분기문 발결 시, NOP 혹은 분기와 관련 없는 명령을 추가해 순서 재배치|비순차 실행과 유사|
|프로그래밍|조건분기 최소화|Inline 메소드 사용, Loop unrolling사용|
참고: https://velog.io/@kio0207/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B4%EB%8B%9D


# 질문 
---

1. PC도 명령어 주소 저장(다음), MAR도 명령어 주소 저장 (현재) 두개의 레지스터를 통합하면 안될까? ex) MAR 없고, PC만 사용 / PC없고, MAR만 사용
   

2. 명령어 실행과정에서 MAR(메모리 주소 레지스터)에 PC(프로그램카운터)에 저장된 메모리 주소를 복사하고, 제어장치가 메모리 읽기 제어신호를 통해 MAR에 있는 주소를 메모리에서 명령어를 읽어오고, 해당 명령어를 MBR에 저장한다. 
   ==메모리 버퍼 레지스터에 메모리 주소 레지스터가 담고 있는 주소에 대한 명령어가 전달되면 PC(프로그램 카운터) 다음 실행할 메모리 주소로 업데이트 된다.== 
   이후, 제어장치가 명령어를 해석하기 위해 MBR에 있는 명령어를 IR로 전달하는데, 
   
   **왜 하필 PC카운트 증가가 저 타이밍에 이루어져야할까?**
   **다른 때에 PC 카운트 증가가 이루어지면 안될까?**
   



