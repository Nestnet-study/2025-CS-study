0. JAVA LinkedHasMap? 구현체 뜯어보기

1. 그래프 완련 알고리즘 - 다익스트라, 플로이드 워샬 등등
2. DAG, 위상정렬
3. MST
4. 해시 (option)
5. 비트마스크 - 네트워크도 약간 첨가 (option)
6. 정렬 (option)


---
### Java - LinkedHashMap
- 기본 동작은 HashMap이되, 각각의 entry를 삽입 순으로 doubly linkedlist 형태로 연결한 자료구조
- 최근 접근한 값을 상단으로 재배열해서 LRU 캐시처럼 사용 가능
- linkedList와 hashmap의 장단점이 보완됨
	- linkedList는 특정 값을 찾는데 O(n) 소요
	- hashmap은 입력 순서에 대한 정보가 기록되지 않음
- TreeMap과 비교했을때의 장단점
	- 장점
		- 삽입, 삭제, 접근 속도
		- 삽입 순서에 대한 정보 유지
	- 단점
		- HashMap의 고질적인 충돌 문제는 여전히 발생
		- n번째로 큰 값, 범위 검색처럼 정렬 기반 연산에는 TreeMap이 유리
- 동적 배열과 비교했을때의 장단점
	- 장점
		- ==값 기반 검색 성능==이 O(1)
			- 위치 기반 조회는 동적배열도 O(1)지만 값 기반 검색은 O(n)
			- 동적배열이 무조건 좋은거 아닌가 생각했었는데 값 기반 검색에 대해서 놓치고 있었다
	- 단점
		- 성능 오버헤드
- [공식문서 뽀개기 - Java 17 기준](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedHashMap.html)
	- multithread 관련
		- 기본적으로 sychorinzed 구현체가 아니라서 멀티쓰레드 환경에서는 wrapping이 필수적
		- 최소한 Collections.synchorizedMap으로 감싸서 사용해야함
	- `The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are late-binding, fail-fast, and additionally report Spliterator.ORDERED.`
		- ? synchroinzed 구현체가 아닌데 spliterator를 리턴한느 이유? stream 표준이 그렇게 되어있어서 그런건가
		- spliterator란
			- split + iterator의 합성어로 ==병렬 처리를 고려한 분할 가능한 반복자==
			- 기존의 iterator는 병렬처리나 데이터 분할을 지원하지 않아서 등장하게 됨
				- ? iterator에 대해서도 다시 개념 정리하고 넘어가기
				- iterator는 단순히 커서 역할만 수행
			- stream 호출 시점에는 파이프라인만 만들어지고 forEach 같은 terminal operation이 호출되는 시점에 source 컬렉션에서 spliterator()가 호출되고 여기서 spliterator 객체가 반환됨
		- fail-fast
			- 컬렉션에서 iterator(), stream()으로 반복을 시작한 뒤 해당 컬렉션이 structual modification이 발생하면 순회 중인 타이밍에 ConcurrentModificationException 발생
			- 컬렉션 내부에 modCount라는 변경 횟수 카운터가 있어서 이 값을 기반으로 검증이 수행됨
			- ? iterator.remove()는 예외 없이 동작하나?
				- YES. 순회 중인 컬렉션에서 특정 값을 안전하게 제거하는 방법
				- 내부적으로 modCount를 증가시켜줌
		- late-binding
			- 데이터가 실제로 처리되는 시점까지 컬렉션의 최신 상태를 반영할 수 있게 바인딩을 미루는 방식
			- late-binding 특징 때문에 한번이라도 데이터가 처리된 이후에만 fail-fast가 발생함
				- stream()이 생성된 collection에 대해서 실제로 순회가 이루어지기 전까지는 구조적 수정이 발생하더라도 문제없음

### 최단경로 알고리즘
- 간선에 가중치가 존재할때 최단경로를 구하는 알고리즘
	- 다익스트라
		- 단일 출발점에서 모든 정점까지의 최단거리
		- 출발점에서 가장 가까운 정점부터 차례대로 방문하는 방식
		- 가중치가 낮은 간선부터 차례대로 방문하고 이미 방문한 노드를 다시 방문하지 않음
			- 귀류법으로 증명한다면
				- 만약 A에서 B까지의 거리가 최소일때 해당 거리가 최적의 거리가 아닐 경우 A->C->B거리가 더 최소여야하는데 이미 A->C의 거리가 A->B 거리보다 큰 상황이므로 모순
			- 가중치에 음수가 있는 경우 해당 증명이 성립하지 않는다
		- 시간복잡도 $O((V+E)*lgE)$

	- 벨만-포드
		- 단일 출발점에서 모든 정점까지의 최단거리
		- 음의 가중치 간선이 있는 경우에도 최단거리를 구할 수 있음
		- 정점이 V개일 때, 사이클 없는 경로는 최대 V - 1개의 간선으로 구성되는 특징을 이용
			- 이러한 특징을 이용해 음의 사이클이 없는지 판별하는 것까지 가능
		- 시간복잡도 $O(V*E)$
	- 플로이드-워셜
		- 모든 정점간의 최단 거리
		- 시간복잡도 $O(V^3)$
		- 메모리를 많이 잡아먹지만 대부분의 경우 E > V이기 때문에 실행시간 측면에서 벨만포드보다 유리함
			- 음의 가중치가 없다면 다익스트라를 n번 돌리는게 나음
- SPT (shortest path tree)
	- 루트 노드에서 다른 노드까지의 최단 경로만을 저장한 트리

### DAG
- Directed Acyclic Graph
- 방향 비순환 그래프
- 위상정렬
	- 구현방식
		- BFS를 이용해서 진입차수가 0인 정점들을 우선 탐색
		- DFS를 이용해서 탐색이 완료된 노드부터 스택에 넣고 역순으로 출력
	- 그래프에 사이클이 존재하는지 여부를 판단하는 것도 가능
		- BFS 방식: 정렬된 노드 수와 전체 노드 수 비교
		- DFS 방식: 탐색 중인 노드를 다시 만나는 경우
- 모든 경로를 탐색하는 경우, 하나의 경로에 대한 정보만 들고 있으면 되는 DFS가 유리함
	- ? 만약 DFS를 재귀함수로 구현한다면 또 다른 이야기이긴 하겠네
	- BFS가 유리한 경우
		- 모든 간선의 가중치가 같고 최단 경로가 필요한 경우
		- A와 B의 선후관계 파악
- DAG 기반 시스템에서의 순환참조는 설계의 적
	- 실행 순서가 모호해지고, 파이프라인이 멈추거나 무한 루프, 의존성 불일치 등의 문제로 이어짐
	- 순환참조를 막기 위한 방법
		- 위상 정렬 검사
		- DFS 기반 실시간 검사
			- A to B 간선을 추가하는 경우, 기존에 B에서 A로의 경로가 있는지 확인해서 검증 (전체 위상정렬 검사 불필요)
		- 계층화된 태스크 구조 설계

- ! SCC도 추가로 공부해보면 좋을듯

### MST
- Minimum Spanning Tree
	- 그래프의 모든 정점을 포함하고, 총 간선 가중치의 합이 최소인 트리
	- 트리는 사이클이 없는 연결 그래프 (Connected Acyclic Graph)
- MST를 구하는 알고리즘
	- 크루스칼의 알고리즘
		1.	모든 간선을 가중치 기준으로 오름차순 정렬
		2.	간선을 하나씩 확인하면서 union-find 연산 O(1)
			- 두 노드가 서로 다른 집합에 속해 있다면 → 그 간선 선택
			- 같은 집합이면 사이클 생기므로 → 버림
		3.	간선이 $|V| - 1$ 개가 되면 종료
		- 시간복잡도 $O(ElgE)$
	- 프림의 알고리즘
		- 트리를 키워나가는 방식
		- 시작 정점에서부터 인접한 가장 작은 간선을 선택
		- 시간복잡도 $O(ElgV)$
	- ? 시간복잡도 측면에서 $V>=E$ 이므로 프림이 항상 좋은거 아닌가?
		- 간선이 적은 경우에는 크루스칼이 유리함
			- heap에서 발생하는 성능 오버헤드
- 실제 시스템에서는 MST와 SPT가 같이 사용되는 경우가 많음
	- MST: 인프라 설계
	- SPT: 실제 운영 경로
	- ex) 버스 노선
		- 노선 수를 최소화하면서 전 지역 커버
		- 특정 정류장에서 다른 정류장까지 최단 시간/최소 환승 경로 탐색
	- MST는 간선 비용 최소화가 목적이기 때문에, 특정 노드 간의 거리가 매우 멀어질 수도 있음 -> MST 이후 SPT를 고려해서 추가 개선이 필요

### 비트마스크
- 비트연산을 할때는 unsinged 자료형을 사용해야한다
- n개의 1로 구성된 비트를 만드는 방법 : 1 << (n+1) - 1
- 최하위비트를 구하는 방법 : a & -a
	- 2의 보수 시스템 활용
