[MST.md]

1. Union-Find 자료구조의 병목 지점은 어디이고, 그것을 시스템적으로 개선할 수 있을까요?
    **병목 지점** : Union-Find의 Find 연산.
    **이유** : Find 연산은 트리의 깊이에 비례하여 시간이 소요되므로, 트리가 깊어지면 성능 저하가 발생.

    **개선 방법**
    - 경로 압축(Path Compression)
      - Find 연산 시, 경로를 따라 모든 노드의 부모를 직접 루트로 설정하여 트리의 깊이를 줄임.
      - `if (parent[x] != x) parent[x] = find(parent[x]);`
    - 랭크 기반 병합
      - Uinon 연산 시, 트리의 깊이를 고려하여 더 작은 트리를 큰 트리에 붙임.
      - `if (rank[a] < rank[b]) parent[a] = b; else parent[b] = a;`
    - 재귀 -> 반복문 변경
<br>

    **대용량 데이터를 처리해야 한다면?**  
    캐시 친화적인 구조 설계 -> 배열 기반의 Union-Find 구현.
    **큰 배열?**
    자바에서 배열은 논리적으로 연속일 뿐, 물리적 메모리 연속성은 보장 안 됨. JVM위에서 동작, 배열도 결국 힙에 할당.
    대형 배열 -> 힙 공간 부족, 메모리 단편화 문제 발생.
    - 이중 배열
      - GC 관리에 유리, 메모리 할당 실패 가능성 줄어듦.
    - Off-heap 구조
      - 직접 메모리 컨트롤 가능, GC 영향 없음.
