# 방향성 비순환 그래프(DAG)와 위상 정렬

## DAG(Directed Acyclic Graph)란?

DAG는 방향성 비순환 그래프로, 다음 두 가지 주요 특성을 가집니다:

1. **방향성(Directed)**: 모든 간선은 한 방향으로만 이동할 수 있습니다.
2. **비순환(Acyclic)**: 그래프 내에 순환(cycle)이 존재하지 않습니다. 즉, 어떤 노드에서 출발하여 다시 같은 노드로 돌아오는 경로가 없습니다.

DAG는 의존 관계나 선후 관계를 표현하는데 매우 유용합니다. 예를 들어:

- 작업 스케줄링(선행 작업이 먼저 완료되어야 함)
- 대학 커리큘럼(선수 과목을 먼저 수강해야 함)
- 소프트웨어 빌드 시스템의 의존성 관계

## 위상 정렬(Topological Sort)

위상 정렬은 DAG의 모든 노드를 선형으로 정렬하는 알고리즘으로, 모든 간선 (u, v)에 대해 정렬된 결과에서 u가 v보다 먼저 오도록 합니다.

### 특징:

- DAG에서만 적용 가능합니다 (순환이 있으면 위상 정렬 불가능)
- 하나의 DAG에 대해 여러 가지 유효한 위상 정렬 결과가 있을 수 있습니다
- 시간 복잡도: O(V+E) (V: 노드 수, E: 간선 수)

### 알고리즘 (두 가지 방법):

1. **Kahn의 알고리즘**:
    - 진입 차수(in-degree)가 0인 노드를 큐에 넣습니다.
    - 큐에서 노드를 하나씩 꺼내 결과 리스트에 추가합니다.
    - 해당 노드에서 나가는 모든 간선을 제거하고, 이로 인해 진입 차수가 0이 된 노드가 있다면 큐에 추가합니다.
    - 큐가 빌 때까지 반복합니다.
2. **깊이 우선 탐색(DFS) 기반 알고리즘**:
    - 모든 노드를 방문하며 DFS를 수행합니다.
    - 방문을 마친 노드를 스택에 추가합니다.
    - 탐색이 끝나면 스택을 뒤집어 결과를 얻습니다.

### 응용 분야:

- 스케줄링 문제
- 프로그램 빌드 시스템
- 선수 과목 계획
- 패키지 의존성 해결
- 데이터 처리 파이프라인

위상 정렬은 "어떤 순서로 작업을 처리해야 모든 의존성을 만족할 수 있는가?"라는 질문에 답을 제공합니다.




# 위상정렬
---







# DAG
---
![](https://i.imgur.com/FQ7ygxS.png)
먼저 모든 edge에 대해서 dist 값을 초기화 해준다. 시작지점은 당연히 왼쪽부터이며, dist값을 비교해가면서 더 작은 값으로 업데이트하는 것이 이제부터 할 작업이다.

![](https://velog.velcdn.com/images%2Fclaude_ssim%2Fpost%2F50908175-ceb5-48fd-a826-5591c5d408ec%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.31.56.png)A는 B, C, D로 outgoing edge를 가지고 있기 때문에, 먼저 B, C, D의 dist 값을 업데이트 해준다. 당연히 처음 단계이기 때문에 무한대보다는 작은 값을 가지고 있어 바로 업데이트가 가능하다.  
![](https://velog.velcdn.com/images%2Fclaude_ssim%2Fpost%2Fd80a838e-1a5e-4a6d-9246-30c7d5a90cff%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.33.06.png)A가 끝났으면, 바로 오른쪽의 C로 향해서 진행하는데, C는 B, D, E로 향하는 edge를 가지고 있다. 그래서 dist(C)와 이 edge들의 정수 값을 합쳤을 때, 이 값이 기존의 dist보다 작으면 업데이트하고 아니면 그냥 냅두면 된다.  
![](https://velog.velcdn.com/images%2Fclaude_ssim%2Fpost%2Fbaba623f-5ed5-42d9-9d3f-e9fb9ad4e3ef%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-09-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.34.54.png)마찬가지로 똑같이 진행해주면 된다.  
![](https://velog.velcdn.com/images%2Fclaude_ssim%2Fpost%2Fd11110e3-b30e-4a04-8659-849efe1e950b%2Fimage.png)더이상 진행이 안되었을 때, 마지막으로 남아있는 dist 값들이 A로 부터의 shortest path가 되는 것이다.
# 방향성 비순환 그래프(DAG)와 위상 정렬

## DAG(Directed Acyclic Graph)란?

DAG는 방향성 비순환 그래프로, 다음 두 가지 주요 특성을 가집니다:

1. **방향성(Directed)**: 모든 간선은 한 방향으로만 이동할 수 있습니다.
2. **비순환(Acyclic)**: 그래프 내에 순환(cycle)이 존재하지 않습니다. 즉, 어떤 노드에서 출발하여 다시 같은 노드로 돌아오는 경로가 없습니다.

DAG는 의존 관계나 선후 관계를 표현하는데 매우 유용합니다. 예를 들어:

- 작업 스케줄링(선행 작업이 먼저 완료되어야 함)
- 대학 커리큘럼(선수 과목을 먼저 수강해야 함)
- 소프트웨어 빌드 시스템의 의존성 관계

## 위상 정렬(Topological Sort)

위상 정렬은 DAG의 모든 노드를 선형으로 정렬하는 알고리즘으로, 모든 간선 (u, v)에 대해 정렬된 결과에서 u가 v보다 먼저 오도록 합니다.

### 특징:

- DAG에서만 적용 가능합니다 (순환이 있으면 위상 정렬 불가능)
- 하나의 DAG에 대해 여러 가지 유효한 위상 정렬 결과가 있을 수 있습니다
- 시간 복잡도: O(V+E) (V: 노드 수, E: 간선 수)

### 알고리즘 (두 가지 방법):

1. **Kahn의 알고리즘**:
    - 진입 차수(in-degree)가 0인 노드를 큐에 넣습니다.
    - 큐에서 노드를 하나씩 꺼내 결과 리스트에 추가합니다.
    - 해당 노드에서 나가는 모든 간선을 제거하고, 이로 인해 진입 차수가 0이 된 노드가 있다면 큐에 추가합니다.
    - 큐가 빌 때까지 반복합니다.
2. **깊이 우선 탐색(DFS) 기반 알고리즘**:
    - 모든 노드를 방문하며 DFS를 수행합니다.
    - 방문을 마친 노드를 스택에 추가합니다.
    - 탐색이 끝나면 스택을 뒤집어 결과를 얻습니다.

### 응용 분야:

- 스케줄링 문제
- 프로그램 빌드 시스템
- 선수 과목 계획
- 패키지 의존성 해결
- 데이터 처리 파이프라인

위상 정렬은 "어떤 순서로 작업을 처리해야 모든 의존성을 만족할 수 있는가?"라는 질문에 답을 제공합니다.