


# HTTP/0.9

초기버전인 HTTP/0.9는 매우 단순한 프로토콜이였다. 
하이퍼텍스트 문서(html)을 가져오기만 하는 GET 동작이 유일했으며, 헤더도 없어 요청과 응답이 극히 당순 명료 하였다.

- TCP/IP 링크 위에서 동작하는 ASCII 프로토콜
- Get 메서드만 지원
- HTTP 헤더 X, 상태 코드 X
- 응답도 HTML 파일 자체만 보내줌
- 서버와 클라이언트 간의 연결은 모든 요청 후에 닫힘(closed)


---

# HTTP/1.0

**기본적인 HTTP 기능들이 추가된 버전**

- 기본적인 HTTP 메서드와 요청/응답 헤더 추가
- HTTP 버전 정보가 각 요청 사이내로 전송되기 시작 (HTTP/1.0 이 GET 라인에 붙은 형태로)
- 상태 코드(status code)가  응답의 시작 부분에 붙어 전송되어, 브라우저가 요청에 대한 성공과 실패를 알 수 있고 그 결과에 대한 동작을 할 수 있게 되었다. (특정 방법으로 로컬 캐시를 갱신하거나 ..등)
- 응답 헤더의 Content-Type 덕분에 HTML 파일 형식 외에 다른 문서들을 전송하는 기능이 추가되었다.
- 단기커넥션 : connection 하나당 1 Request & 1 Response 처리 가능

### 1.0문제점

#### **Short-lived Connection**

**Short-lived Connection (단기 커넥션)**

- 매 요청마다 새로운 TCP 연결 필요
- 웹페이지 로드 시 HTML, CSS, JS, 이미지 등 각 리소스마다 별도 연결
- 연결 설정/해제 반복으로 성능 저하 및 서버 부하 증가

```
웹페이지 로드 과정:
1. TCP 연결 → HTML 요청 → 응답 → 연결 종료
2. TCP 연결 → CSS 요청 → 응답 → 연결 종료  
3. TCP 연결 → JS 요청 → 응답 → 연결 종료
4. TCP 연결 → 이미지 요청 → 응답 → 연결 종료
...반복
```

![단기커넥션](https://blog.kakaocdn.net/dna/bnMVmL/btrRg7Pqvma/AAAAAAAAAAAAAAAAAAAAAMvh_6FiT9JF2fn_ULVwynuxpnVTpOt1b3K7XCsgjXey/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1753973999&allow_ip=&allow_referer=&signature=tLOKvXiSZ4xJfhwc9V0WNqoMrKQ%3D)

예를들어 웹페이지를 요청하면 html과 그에 딸린 css나 js 및 이미지 등등 수 많은 자원들이 다운로드되어 화면에 띄울 텐데, 각 자원들을 따로 따로 매번 TCP 연결하고 다운받고 연결 끊고 다시 연결하고 다운 받고 연결 끊는 것이다.

그래서 HTTP 초기에는 모든 자료에 대해서 비연결성으로 각각의 자원에 대해 연결/응답/종료를 반복하다보니 느렸다.




# HTTP/1.1


HTTP/1.0의 단점을 해결하기 위해 1997년 출시된 버전으로, 현재 가장 많이 사용되는 프로토콜입니다. HTTP/1.0이 출시된 지 불과 6개월 만에 릴리즈되었으며, 많은 프로토콜 모호성을 해결하고 크리티컬한 성능 개선을 도입했습니다.


## 주요 개선사항

### 1. 지속 연결 (Persistent Connection / Keep-Alive)

HTTP/1.0의 가장 큰 문제였던 **Short-lived Connection**을 해결한 핵심 기능입니다.

**기본 개념**

- 지정한 timeout 동안 연결을 끊지 않고 유지
- 여러 요청/응답을 하나의 TCP 연결로 처리
- 불필요한 TCP handshake를 줄여 성능 향상

**동작 방식**

```
HTTP/1.0: 연결 → 요청 → 응답 → 연결 종료 (매번 반복)
HTTP/1.1: 연결 → 요청1 → 응답1 → 요청2 → 응답2 → ... → 연결 종료
```

**Keep-Alive 헤더 설정**

- HTTP/1.1부터는 기본적으로 Keep-Alive가 활성화
- HTTP/1.0+에서는 명시적으로 헤더에 설정 필요:
    
    ```
    Connection: keep-alive
    Keep-Alive: max=5, timeout=120
    ```
    

**Keep-Alive 파라미터**

- **max**: 연결에서 처리할 수 있는 최대 요청 수
- **timeout**: 연결을 유지할 최대 시간(초)

**연결 종료** 필요한 리소스를 모두 받은 후 연결을 종료하려면:

```
Connection: close
```



### 2. 파이프라이닝 (Pipelining)

이전 요청의 응답을 기다리지 않고 여러 요청을 연속적으로 보낼 수 있는 기능입니다.


**장점**

- 여러 요청을 한꺼번에 보내 대기시간 단축
- Keep-Alive와 함께 사용하여 성능 개선

**동작 원리**

```
기존 방식: 요청1 → 응답1 → 요청2 → 응답2 → 요청3 → 응답3
파이프라이닝: 요청1,2,3 → 응답1,2,3 (순서대로 수신)
```

**문제점과 한계**

- **Head-of-Line Blocking**: 첫 번째 요청이 지연되면 모든 응답이 지연
- 응답 순서를 지키기 위해 처리가 지연될 수 있음
- 구현 복잡성으로 인해 대부분의 브라우저에서 비활성화
- HTTP/2의 멀티플렉싱으로 대체됨

### 3. HOST 헤더 추가

하나의 IP 주소에서 여러 도메인을 호스팅할 수 있는 기능입니다.

**기능**

```
Host: www.example.com
Host: blog.example.com
```

동일한 서버에서 여러 사이트 운영 가능

### 4. 기타 개선사항

**Chunk Encoding 전송**

- 응답을 여러 조각으로 나누어 전송
- Content-Length를 미리 알 수 없는 경우 유용

**바이트 범위 요청**

- 파일의 특정 부분만 요청 가능
- 이어받기, 스트리밍에 활용

**캐시 제어 메커니즘**

- 더 정교한 캐시 제어 헤더 도입
- 효율적인 리소스 관리

## Domain Sharding

파이프라이닝의 한계를 극복하기 위한 차선책으로 등장한 기술입니다.

**개념**
- 하나의 도메인에 대해 여러 TCP 연결을 생성
- 보통 6~13개의 병렬 연결로 리소스를 동시 다운로드
- 브라우저별로 도메인당 연결 개수 제한 존재

**한계**
- DNS Lookup 시간 증가
- 추가 메모리와 리소스 사용
- 근본적인 해결책이 아님



## HTTP/1.1의 주요 문제점

### 1. Head-of-Line Blocking (HOLB)

파이프라이닝에서 발생하는 가장 큰 문제입니다.

**문제 상황**
```
요청: [대용량 이미지] [작은 CSS] [작은 JS]
응답: 대용량 이미지 처리 지연 → 모든 응답 지연
```

첫 번째 요청이 큰 데이터라면, 뒤의 작은 데이터들도 함께 지연되는 현상입니다.

### 2. RTT (Round Trip Time) 증가

**문제점**
- TCP 기반이므로 여전히 handshake 필요
- 컨텐츠가 증가하면서 누적되는 레이턴시 부담
- Keep-Alive로 개선되었지만 완전히 해결되지 않음

### 3. 무거운 헤더 구조와 중복

**문제 상황**
- 매 요청마다 쿠키 등 메타정보가 헤더에 포함
- 헤더 크기가 실제 전송 데이터보다 큰 경우 발생
- 연속된 요청에서 중복된 헤더 정보 반복 전송
- 메모리 자원 낭비

**예시**
```
첫 번째 요청: User-Agent, Cookie, Accept 등 (2KB)
두 번째 요청: 동일한 헤더 반복 (2KB)
실제 데이터: 작은 JSON (500B)
→ 헤더가 데이터보다 4배 큼
```

이러한 한계들은 결국 HTTP/2의 등장 배경이 되었으며, 바이너리 프레이밍, 헤더 압축, 멀티플렉싱 등으로 해결되었습니다.
























참고: [https://inpa.tistory.com/entry/WEB-🌐-HTTP-09-HTTP-30-까지-알아보는-통신-기술#http_/_1.0](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-09-HTTP-30-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0#http_/_1.0) [Inpa Dev 👨‍💻:티스토리]