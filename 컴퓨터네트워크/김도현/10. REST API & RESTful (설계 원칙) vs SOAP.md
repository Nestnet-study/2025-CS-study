# REST

## 1. REST
---

### REST 란?
---
**REST(Representational State Transfer)**는 월드 와이드 웹과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식입니다.

REST는 **웹의 기존 기술과 HTTP 프로토콜을 그대로 활용**하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이며, 네트워크 상에서 클라이언트와 서버 사이의 통신 방식 중 하나입니다.

##### 핵심 개념
**자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것** 즉, **자원(resource)의 표현(representation)에 의한 상태 전달**

 
##### **자원(Resource)과 표현(Representation)**
- **자원**: 해당 소프트웨어가 관리하는 모든 것
    - 예: 문서, 그림, 데이터, 소프트웨어 자체 등
- **자원의 표현**: 그 자원을 표현하기 위한 이름
    - 예: DB의 학생 정보가 자원일 때, `students`를 자원의 표현으로 사용


##### 상태(정보) 전달
- 데이터가 요청되는 시점에서 **자원의 상태(정보)를 전달**
- **JSON 혹은 XML**을 통해 데이터를 주고받는 것이 일반적



### REST 구체적인 개념
---

**HTTP URI를 통해 자원을 명시하고, HTTP Method를 통해 해당 자원에 대한 CRUD Operation을 적용**

- **자원 기반 구조(ROA, Resource Oriented Architecture)** 설계의 중심에 Resource가 있음
- HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍처
- 모든 자원에 **고유한 ID인 HTTP URI를 부여**

### CRUD Operation

| Operation     | HTTP Method | 설명       |
| ------------- | ----------- | -------- |
| **Create**    | POST        | 생성       |
| **Read**      | GET         | 조회       |
| **Update**    | PUT         | 수정       |
| **Delete**    | DELETE      | 삭제       |
| **Header 조회** | HEAD        | 헤더 정보 조회 |



### REST의 장단점
---

#### 장점

- **별도 인프라 구축 불필요**: HTTP 프로토콜 인프라를 그대로 사용
- **다양한 장점 확보**: HTTP 프로토콜 표준을 최대한 활용
- **플랫폼 독립적**: HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능
- **범용성 보장**: Hypermedia API의 기본을 충실히 준수
- **명확한 의도 파악**: REST API 메시지가 의도하는 바를 쉽게 이해
- **문제 최소화**: 다양한 서비스 디자인에서 생길 수 있는 문제를 최소화
- **역할 분리**: 서버와 클라이언트의 역할을 명확하게 구분

#### 단점

- **표준 부재**: 공식적인 표준이 존재하지 않음
- **제한적 HTTP Method**: 사용할 수 있는 HTTP Method 형태가 한정적
- **테스트 복잡성**: 브라우저 테스트 시 Header 값이 URL보다 복잡하게 느껴질 수 있음



### REST가 필요한 이유
---

### 애플리케이션 분리 및 통합

현대의 서버 프로그램은 **다양한 브라우저와 모바일 디바이스**(안드로이드, iPhone 등)에서 통신할 수 있어야 합니다.

이러한 **멀티 플랫폼 지원**을 위해 서비스 자원에 대한 아키텍처를 구축하고 활용하는 방법으로 REST가 주목받게 되었습니다.



### REST 구성 요소
---

#### 1. 자원(Resource): URI

- **모든 자원에 고유한 ID 존재**, 이 자원은 서버에 존재
- 자원을 구별하는 ID는 `/groups/:group_id`와 같은 **HTTP URI**
- 클라이언트는 URI를 이용해 자원을 지정하고 해당 자원의 상태에 대한 조작을 서버에 요청

#### 2. 행위(Verb): HTTP Method

- **HTTP 프로토콜의 Method 사용**
- GET, POST, PUT, DELETE 등의 메서드 제공

#### 3. 표현(Representation of Resource)

- 클라이언트가 자원의 상태에 대한 조작을 요청하면 **서버는 적절한 응답을 전송**
- 하나의 자원은 **JSON, XML, TEXT, RSS** 등 여러 형태로 표현 가능
- **JSON 혹은 XML**을 통한 데이터 교환이 일반적



### REST 특징
---

#### 1. Server-Client (서버-클라이언트 구조)

- **자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client**
- **REST Server**: API 제공, 비즈니스 로직 처리 및 저장 책임
- **Client**: 사용자 인증, context(세션, 로그인 정보) 등을 직접 관리
- **서로 간 의존성이 감소**

#### 2. Stateless (무상태)

- **HTTP 프로토콜이 Stateless Protocol**이므로 REST도 무상태성을 가짐
- **클라이언트의 context를 서버에 저장하지 않음**
    - 세션과 쿠키 같은 context 정보를 신경 쓸 필요가 없어 구현이 단순
- **각 요청을 완전히 별개로 인식하고 처리**
    - 이전 요청이 다음 요청 처리에 연관되어서는 안 됨
    - DB 수정을 통한 변경은 허용
    - 서버 처리 방식의 일관성과 서비스 자유도 향상

#### 3. Cacheable (캐시 처리 가능)

- **웹 표준 HTTP 프로토콜을 그대로 사용**하므로 기존 웹 인프라 활용 가능
- **HTTP의 강력한 캐싱 기능 적용** 가능
- Last-Modified 태그나 E-Tag를 이용한 캐싱 구현
- **응답시간 단축, 성능 향상, 서버 자원 이용률 개선**

#### 4. Layered System (계층화)

- **클라이언트는 REST API 서버만 호출**
- **REST 서버는 다중 계층으로 구성** 가능
    - API 서버는 순수 비즈니스 로직 수행
    - 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증 등 추가
    - 구조상의 유연성, 확장성, 보안성 향상
- **PROXY, 게이트웨이** 같은 네트워크 기반 중간 매체 사용 가능

#### 5. Code-On-Demand (선택사항)

- **서버로부터 스크립트를 받아 클라이언트에서 실행**
- **반드시 충족할 필요는 없는 선택적 특징**

#### 6. Uniform Interface (인터페이스 일관성)

- **URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행**
- **HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능**
- **특정 언어나 기술에 종속되지 않음**





## 2. REST API 
---


### REST API의 정의
---
**REST 기반으로 서비스 API를 구현**한 것으로, 최근 대부분의 서비스에서 표준으로 사용되고 있습니다.

- **OpenAPI**: 구글 맵, 공공 데이터 등 누구나 사용할 수 있도록 공개된 API
- **마이크로서비스**: 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 분리하여 변경과 조합이 가능하도록 만든 아키텍처



### REST API의 특징
---
REST는 **HTTP 표준을 기반**으로 구현되므로, HTTP를 지원하는 모든 프로그래밍 언어로 클라이언트와 서버를 구현할 수 있습니다.

즉, REST API를 제작하면 **델파이, 자바, C#, 웹** 등 다양한 플랫폼에서 클라이언트를 제작할 수 있습니다.




### REST API 설계 기본 규칙
---
#### 리소스 원형
- **도큐먼트**: 객체 인스턴스나 데이터베이스 레코드와 유사한 개념
- **컬렉션**: 서버에서 관리하는 디렉터리라는 리소스
- **스토어**: 클라이언트에서 관리하는 리소스 저장소

#### 1. URI는 정보의 자원을 표현해야 한다

- **리소스명은 동사보다는 명사를, 대문자보다는 소문자를 사용**
- **도큐먼트 이름**: 단수 명사 사용
- **컬렉션 이름**: 복수 명사 사용
- **스토어 이름**: 복수 명사 사용

```
❌ GET /Member/1
✅ GET /members/1
```

#### 2. 자원에 대한 행위는 HTTP Method로 표현한다

- **URI에 HTTP Method가 들어가면 안 됨**

```
❌ GET /members/delete/1
✅ DELETE /members/1
```

- **URI에 행위에 대한 동사 표현이 들어가면 안 됨** (CRUD 기능을 나타내는 것은 URI에 사용 금지)

```
❌ GET /members/show/1
✅ GET /members/1

❌ GET /members/insert/2  
✅ POST /members/2
```

- **경로 부분 중 변하는 부분은 유일한 값으로 대체** (:id는 특정 리소스를 나타내는 고유값)

```
✅ POST /students          // student 생성
✅ DELETE /students/12     // id=12인 student 삭제
```
    

#### **REST API 설계 규칙**

1. **슬래시 구분자(/ )는 계층 관계를 나타내는데 사용한다.**  
    ex) [http://restapi.example.com/houses/apartments](http://restapi.example.com/houses/apartments)

2. **URI 마지막 문자로 슬래시(/ )를 포함하지 않는다.**
    - URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고, 역으로 리소스가 다르면 URI도 달라져야 한다.
    - REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다.  
        ex) [http://restapi.example.com/houses/apartments/](http://restapi.example.com/houses/apartments/) (X)
    
3. **하이픈(- )은 URI 가독성을 높이는데 사용**
    - 불가피하게 긴 URI경로를 사용하게 된다면 하이픈을 사용해 가독성을 높인다.
    
4. **밑줄(_ )은 URI에 사용하지 않는다.**
    - 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 하므로 가독성을 위해 밑줄은 사용하지 않는다.
    
5. **URI 경로에는 소문자가 적합하다.**
    - URI 경로에 대문자 사용은 피하도록 한다.
    - RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정하기 때문
    
6. **파일확장자는 URI에 포함하지 않는다.**
    - REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
    - Accept header를 사용한다.  
        ex) [http://restapi.example.com/members/soccer/345/photo.jpg](http://restapi.example.com/members/soccer/345/photo.jpg) (X)  
        ex) GET / members/soccer/345/photo HTTP/1.1 Host: restapi.example.com Accept: image/jpg (O)
    
7. **리소스 간에는 연관 관계가 있는 경우**
    - /리소스명/리소스 ID/관계가 있는 다른 리소스명  
        ex) GET : /users/{userid}/devices (일반적으로 소유 ‘has’의 관계를 표현할 때)







## 3. RESTful
---


#### **RESTful이란**

- RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다.
    - ‘REST API’를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있다.
    
- RESTful은 REST를 REST답게 쓰기 위한 방법으로, 누군가가 공식적으로 발표한 것이 아니다.
    - 즉, REST 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.
    

#### **RESTful의 목적**

- **이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것**
- RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 **일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것**이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다.
- **RESTful 하지 못한 경우**  
    ex1) CRUD 기능을 모두 POST로만 처리하는 API  
    ex2) route에 resource, id 외의 정보가 들어가는 경우(/students/updateName)





참고: https://hahahoho5915.tistory.com/54





# 2. SOAP과 REST vs SOAP 비교
---


## SOAP의 정의
---

**SOAP (Simple Object Access Protocol)** 는 애플리케이션 간 통신을 위한 **프로토콜**입니다.

### SOAP의 특징

SOAP는 **엄격한 통신 규칙을 정의**하며, 시스템 간 엄격한 통신 계약이 필요한 기술입니다. 데이터 교환의 모든 측면을 제어하는 여러 관련 표준들이 있습니다:

- **웹 서비스 보안(WS-Security)**: 고유 식별자로 토큰을 사용하는 보안 조치 지정
- **웹 서비스 주소 지정(WS-Addressing)**: 라우팅 정보를 메타데이터로 포함
- **WS-ReliableMessaging**: SOAP 메시징의 오류 처리 표준화
- **웹 서비스 기술 언어(WSDL)**: SOAP 웹 서비스의 범위와 기능 설명

### SOAP의 작동 방식

SOAP API로 요청을 보낼 때는 **HTTP 요청을 SOAP 봉투에 포장**해야 합니다. 이는 SOAP 요청 요구사항을 사용하여 기본 HTTP 콘텐츠를 수정하는 데이터 구조입니다.

봉투 때문에 **TCP나 인터넷 제어 메시지 프로토콜(ICMP) 같은 다른 전송 프로토콜**을 사용하여 SOAP 웹 서비스에 요청을 보낼 수도 있습니다. 하지만 SOAP API와 SOAP 웹 서비스는 **항상 XML 문서로 응답**을 반환합니다.

시간이 지남에 따라 기술 변화를 수용하기 위해 새로운 웹 서비스 표준이 추가되었지만, 이로 인해 **추가 오버헤드가 발생**합니다.



## SOAP와 REST 비교
---

| 구분          | SOAP                          | REST                            |
| ----------- | ----------------------------- | ------------------------------- |
| **정의**      | Simple Object Access Protocol | Representational State Transfer |
| **특성**      | 애플리케이션 간 통신을 위한 프로토콜          | 통신 인터페이스 설계를 위한 아키텍처 스타일        |
| **설계**      | 작업을 노출                        | 데이터를 노출                         |
| **전송 프로토콜** | 독립적, 모든 전송 프로토콜과 작동 가능        | HTTPS에서만 작동                     |
| **데이터 형식**  | XML 데이터 교환만 지원                | XML, JSON, 일반 텍스트, HTML 지원      |
| **성능**      | 메시지가 커서 통신 속도 느림              | 작은 메시지와 캐싱 지원으로 빠른 성능           |
| **확장성**     | 확장 어려움 (상태 유지 필요)             | 확장 용이 (무상태 방식)                  |
| **보안**      | 추가 오버헤드가 있는 암호화 지원            | 성능 영향 없는 암호화 지원                 |
| **사용 사례**   | 레거시 애플리케이션 및 프라이빗 API         | 최신 애플리케이션 및 공개 API              |



### 선택 기준
---

**SOAP를 선택하는 경우:**
- 레거시 시스템 통합이 필요한 경우
- 엄격한 보안 요구사항 (기업 내부 요구사항, 규정 준수)
- ACID 규정 준수가 필요한 경우 (금융 트랜잭션 등)
- 높은 신뢰성과 데이터 무결성이 중요한 시스템

**REST를 선택하는 경우:**
- 최신 애플리케이션 개발 (모바일 앱, 하이브리드 애플리케이션)
- 마이크로서비스 아키텍처 사용
- 퍼블릭 API 제공 (높은 유연성과 접근성 필요)
- 성능과 확장성을 중시하는 경우


참고: https://aws.amazon.com/ko/compare/the-difference-between-soap-rest/