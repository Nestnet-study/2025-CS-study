# HTTP의 기본과 HTTP/1.1

## 1. 주요 특징

### 주요 특징

- **지속적 연결 (Persistent Connection)**: Keep-Alive를 기본적으로 사용함.
- **파이프라이닝 (Pipelining)**: 하나의 연결에서 순차적으로 여러 개의 요청을 보낼 수 있음. 하나의 요청에 대한 응답을 기다리는 방식이 아님. 하지만 먼저 보낸 요청의 처리가 늦어지면 그 뒤 요청도 모두 지연되는 HOL Blocking 문제가 존재함.
- **호스트 헤더 (Host Header)**: 가상 호스팅 지원
  - 기존에는 하나의 IP 주소 = 하나의 웹사이트로 사용
  - 가상 호스팅이 도입되면서 Host 헤더가 필수가 됨. Host 헤더를 통해 같은 서버 IP여도 다른 웹사이트를 운영할 수 있게됨.
- `Cache-Control`, `ETag` 등 다양한 헤더를 이용해 캐시를 효과적으로 관리할 수 있게 됨

---

## 2. 주요 메서드와 멱등성(Idempotence)

HTTP 요청은 메서드를 통해 서버에 수행할 동작의 종류를 알린다. 이 메서드들은 멱등성을 기준으로 나눌 수 있다.

- 멱등성은 동일한 요청을 여러 번 보내는 것과, 한 번 보내는 것이 동일한 집합 내에서 이루어지는 성질을 말한다. 즉, 여러 번 요청해도 서버의 상태는 한 번만 요청했을 때와 똑같이 유지된다면 멱등성이 보장되는 것이다.

GET, PUT, DELETE 등의 요청은 멱등성이 보장된다.

- 클라이언트가 요청 후 응답을 받지 못했을 때, 요청이 서버에 도달했는지 여부와 상관없이 안전하게 재요청을 보낼 수 있다.
- 예를 들어, `DELETE /users/123` 요청을 여러 번 보내도 첫 번째 요청에서 이미 삭제되었으므로 서버의 최종 상태는 동일하다.

POST, PATCH 등은 멱등성이 보장되지 않는다.

- `POST`를 통해 게시글을 작성하는 요청을 여러 번 보내면, 동일한 내용의 게시글이 여러 개 생성될 수 있다.
- 이처럼 반복 요청 시 서버 상태가 계속 변경되므로 재요청에 주의가 필요하다.

### 각 메서드의 역할

**GET**

- 서버의 상태를 변경하지 않고, 단순히 데이터를 가져와 보여줄 때 사용한다.
- 멱등성이 보장된다.

**POST**

- 새로운 자원을 만들어 서버의 상태를 변경할 때 사용한다.
- 멱등성이 없다.

**DELETE**

- 서버의 특정 자원을 삭제할 때 사용한다.
- 서버의 상태를 변경하지만 멱등성은 보장된다.

메서드의 역할은 약속이지만 굉장히 중요하다. 예를 들어 GET으로 데이터를 삭제한다면 다음의 문제점이 발생될 수 있다.

1. 검색엔진 크롤러는 웹사이트의 링크를 따라다니며 GET 요청을 자동으로 보내는 방식으로 작동한다. GET은 서버의 상태를 변경하지 않는 요청이므로 크롤러가 요청을 보내도 문제가 없어야 한다. 하지만 GET으로 삭제를 구현한다면 크롤러가 멋대로 모든 게시글을 삭제할 수도 있다.
2. 브라우저가 멋대로 동작할 수 있다.

   일부 웹 브라우저는 속도 향상을 위해 페이지의 링크를 미리 읽어오는 프리패치 기능을 사용한다. 이 기능 역시 GET은 안전하다고 가정하고 동작하므로 이상 현상이 발생할 수 있다.

### GET VS POST

GET 요청은 데이터를 URL의 ? 뒤에 `key=value` 형식으로 전송한다. 이를 Query String이라 한다.

- **형태**: `URL?name1=value1&name2=value2`

**특징**

- **데이터 노출**: 데이터가 주소창에 그대로 드러나므로, 비밀번호 등 민감한 정보를 보내는 데 부적합하다.
- **길이 제한**: 브라우저나 서버에 따라 URL 길이에 제한이 있어 많은 양의 데이터를 보낼 수 없다.
- **북마크 가능**: 데이터가 포함된 URL 자체를 북마크하거나 다른 사람에게 공유할 수 있다.

POST는 데이터를 Request Body에 실어서 보낸다.

### POST: 본문(Body)에 데이터를 숨겨 싣는다 📝

- **형태**:HTTP
  ```json
  POST /login HTTP/1.1
  Host: example.com
  Content-Type: application/json

  {
    "username": "my_id",
    "password": "my_secret_password"
  }
  ```

**특징**

- **보안에 유리**: 데이터가 URL에 노출되지 않아 GET보다 안전하다.
- **길이 제한 없음**: 대용량 데이터를 전송할 수 있다.

---

## 3. 경로 변수 VS 쿼리 스트링

### 경로 변수 (Path Variable)

`.../posts/123`

특정 자원을 고유하게 식별할 때 사용한다. URL 경로 자체가 자원의 주소 역할을 하는 것이다.

- **역할**: 특정 자원(리소스)을 정확히 지정.
- **의미**: `/posts/123`은 "게시글들 중에서 123번 게시글 자체"를 의미한다.
- 게시글 ID, 사용자 ID처럼 고유한 값을 가리킬 때, 혹은 자원 간 관계나 계층을 표현할 때 사용한다.
  - `GET /teams/blue/players/7` (blue팀의 7번 선수를 줘)

### 쿼리 스트링 (Query String)

`...?page=2&sort=popular`

이 방식은 특정 자원 목록에 대해 정렬, 필터링, 검색 등 추가적인 옵션을 전달할 때 사용한다. 자원을 식별하는 것이 아니라, "어떻게 보여달라"는 부가적인 요청이다.

- **역할**: 데이터 표현 방식을 제어(정렬, 필터링, 검색, 페이지네이션).
- **의미**: `/posts?sort=popular`는 "게시글 목록을 인기순으로 정렬해서 보여줘"를 의미한다.
- 데이터를 정렬할 때 (`sort=latest`), 검색할 때, 페이지 번호를 지정할 때 많이 사용한다.

실제 웹 서비스에서는 아래와 같이 두 가지를 함께 사용한다.

- `GET /boards/free/posts?page=2&sort=popular`
  - `/boards/free/posts` (**경로 변수**): "자유(free) 게시판의 게시글 목록"이라는 특정 자원을 식별한다.
  - `?page=2&sort=popular` (**쿼리 스트링**): 식별된 자원에 대해 "인기순으로 정렬해서 2페이지를 보여줘"라는 옵션을 전달한다.

사실 게시글 ID, 유저 ID와 같은 것들은 쿼리 스트링으로도 많이 사용한다. 실제로 그런 케이스들도 있고 오해인 부분도 존재한다.

레거시 시스템의 경우 RESTful 디자인 원칙이 엄격히 지켜지지 않거나, 원칙이 없을 당시 만든 시스템이라 그런 경우가 대부분이다.

반면 ID가 리소스 자체를 식별하는 것이 아니라 필터링 조건으로 사용될 때는 ID를 쿼리 스트링으로 표현하는 것이 더 자연스럽다. 예시로 보자.

- `GET /users/123` → 123번 유저 자체를 가리킴
- `GET /posts?author_id=123` → 123번 유저가 쓴 “게시글 목록”을 가리킴
