# 쿠키, 세션, 토큰

HTTP 프로토콜은 Stateless 프로토콜이다. 클라이언트와 서버의 통신이 매번 독립적으로 이루어지므로 서버는 방금 통신했던 클라이언트가 다음 요청을 보냈을 때, 그 클라이언트가 누구였는지 전혀 기억하지 못한다.

따라서 특히 로그인 부분에서 큰 문제가 발생하였고, 로그인을 비롯한 모든 상태를 유지하기 위해 쿠키, 세션, 토큰이 등장하였다

---

## **1. 쿠키**

쿠키는 세션과 토큰을 구현하기 위한 가장 기본적인 기반 기술이다.

- 서버가 클라이언에게 작은 데이터 조각을 보내고, 브라우저는 이 쿠키를 자신의 저장소에 보관했다가 이후 해당 서버에 요청을 보낼 때마다 자동으로 첨부해서 보내게 된다.
- **동작 원리**
  1. 클라이언트가 서버에 최초 요청을 보낸다.
  2. 서버는 응답 헤더(Header)에 `Set-Cookie`라는 필드를 추가하여 쿠키를 보낸다.
  3. 브라우저는 이 쿠키를 저장하고 이후 클라이언트가 같은 서버에 요청을 보낼 때, 요청 헤더에 `Cookie` 필드를 자동으로 추가하여 저장된 쿠키를 함께 보낸다.

---

## **2. 세션**

세션은 쿠키를 이용하여 구현되는 전통적인 상태 관리 방식이다.

- 사용자의 중요한 정보를 브라우저가 아닌 서버에서 저장하고 관리하는 방식이다. 서버는 각 클라이언트를 구별하기 위해 고유한 세션 ID를 발급하며, 이 세션 ID를 통해 클라이언트를 식별한다.
- 클라이언트는 중요한 정보를 전혀 표현하지 않고 서버가 발급한 세션 ID만을 쿠키로 관리한다.
- **동작 원리**
  1. **로그인:** 사용자가 아이디/비밀번호로 서버에 로그인 요청을 한다.
  2. **세션 생성:** 서버는 사용자의 정보를 확인하고, 이 사용자를 위한 세션 객체를 데이터베이스에 생성한다.
  3. **세션 ID 발급:** 서버는 생성된 세션 객체를 식별할 수 있는 길고 무작위적인 세션 ID를 생성한다.
  4. **응답 (쿠키 전달):** 서버는 응답 시 `Set-Cookie` 헤더를 통해 이 세션 ID를 클라이언트에게 전달한다.
  5. **이후 요청:** 클라이언트는 이후 모든 요청에 이 세션 ID가 담긴 쿠키를 자동으로 실어 보낸다.
  6. **인증:** 서버는 요청 쿠키에서 세션 ID를 확인하고, 서버의 세션 저장소에서 해당 ID와 일치하는 세션 객체를 찾아 사용자 정보를 확인함으로써 요청을 인증하고 처리한다.

**장점**

- 민감한 사용자 정보가 서버에 저장되므로 보안에 유리하며 세션 만료 또한 용이하다.

**단점**

- 서버의 메모리나 저장 공간을 차지하며, 사용자가 많아지면 서버에 부하가 걸릴 수 있다.
- 특히 MSA에서는 세션 정보를 공유하기 위한 별도의 세션 클러스터링이나 중앙 세션 저장소가 필요하다.

---

## **3. 토큰**

토큰은 세션 방식의 단점을 보완하기 위해 등장한 현대적인 상태 관리 방식이다.

- 토큰은 사용자의 인증 정보와 권한 등을 담은 암호화된 데이터 조각이다. 이 암호화를 서명된 데이터라 한다.
- 필요한 모든 정보를 토큰 자체가 담고 있으므로 서버는 Stateless를 지킬 수 있다.
- 토큰은 보통 Local Storage나 쿠키게 저장되어 사용된다.
- **JWT의 구조:** `Header.Payload.Signature` 세 부분이 `.`으로 연결된 구조입니다.
  - **Header:** 토큰의 타입(JWT)과 서명에 HS256과 같은 사용된 암호화 알고리즘 정보가 담긴다.
  - **Payload:** 전달하려는 실제 데이터가 담긴다. 사용자 ID, 이름, 권한, 만료 시간 등이 포함되며 이 부분은 암호화되지 않기에 민감한 정보를 담아서는 안된다.
  - **Signature :** Header와 Payload를 서버만 아는 비밀 키로 서명한 값이다. 이 서명을 통해 토큰이 변조되지 않음을 검증할 수 있다.
- **동작 원리**
  1. **로그인:** 사용자가 아이디/비밀번호로 서버에 로그인을 요청한다.
  2. **토큰 생성 및 서명:** 서버는 사용자의 정보를 확인하고, Payload에 사용자 정보를 담아 JWT를 생성한다. 그리고 서버의 비밀 키로 이 토큰에 서명한다.
  3. **응답 (토큰 전달):** 서버는 생성된 JWT를 응답 본문(Body)에 담아 클라이언트에게 전달한다.
  4. **저장:** 클라이언트는 전달받은 JWT를 Local Storage, Sesstion Storage 혹은 쿠키에 저장한다.
  5. **이후 요청:** 클라이언트는 이후 모든 요청에 이 JWT를 **`Authorization: Bearer <JWT>`** 형식으로 HTTP 헤더에 담아 보낸다.
  6. **인증:** 서버는 요청 헤더의 JWT를 받고, 자신이 가진 비밀 키로 서명을 검증한다. 서버는 자신의 저장소를 뒤져볼 필요 없이, 서명의 유효성만 검증하면 된다.

**장점**

- 서버의 Stateless를 보장하므로 확장성이 매우 뛰어나다. 따라서 MSA에 최적화되어 있다.

**단점**

- 한 번 발급된 토큰은 만료되기 전까지 계속 유효하므로 중간에 탈취되면 위험할 수 있다. 또한 토큰을 강제로 만료시키기는 어렵다.

### **액세스 토큰과 리프레시 토큰**

**액세스 토큰**

- 인가를 담당한다. 특정 API에 접근할 수 있는 권한을 증명하는 것이다.
- 수명이 매우 짧아 탈취되더라도 피해가 제한적이다.
- 서버는 이 토큰의 서명만 검증하면 된다.
- 사용자의 권한과 같은 정보가 담겨있다.

**리프레시 토큰 (Refresh Token)**

- 인증을 담당한다. 새로운 액세스 토큰을 발급받기 위한 자격 증명이다.
- 수명이 길다.
- 액세스 토큰 재발급 용도로만 사용되며, API 접근에는 직접 사용되지 않는다.
- 탈취되면 매우 위험하다.

---

## 4. 토큰의 흐름

### **Step 1: 최초 인증**

- 데이터베이스에서 아이디와 비밀번호가 일치하는지 확인한다.
- 인증에 성공했으므로, 이 사용자를 위한 두 가지 토큰을 모두 만든다.
  - **액세스 토큰:** JSON 응답 본문(Body)에 담아 전달한다. 클라이언트의 자바스크립트가 직접 접근해서 사용해야 하기 때문이다.
  - **리프레시 토큰:** 보안을 위해 `HttpOnly`, `Secure` 속성이 적용된 쿠키에 담아 전달한다.
    - `HttpOnly`: XSS 공격 방어를 위한 속성으로 자바스크립트가 이 쿠키에 접근하는 것을 차단한다.
    - `Secure`: HTTPS 연결에서만 쿠키가 전송되도록 한다.
    - `Path`: `/api/token/refresh`과 같은 리프레시 토큰이 필요한 특정 경로에서만 쿠키가 전송되도록 제한한다.
- 생성된 두 토큰을 클라이언트에게 전달한다.

### **Step 2: 인가 (API 요청)**

1. **클라이언트:** '마이페이지' 정보를 요청하기 위해 `GET /api/mypage` API를 호출한다. 이때, 요청 헤더(Header)의 `Authorization` 필드에 **액세스 토큰**을 담아 보낸다.
   - `Authorization: Bearer <액세스_토큰_내용>`
2. **서버:** 요청 헤더에서 엑세스 토큰을 확인한다. 이때 서명, 만료일, 권한을 모두 검증한다.

### **Step 3: 액세스 토큰 만료**

1. 15분이 지난 상태에서 사용자가 다른 버튼을 눌러 다시 API를 요청한다. 만료된 액세스 토큰을 보내는 것이다.
2. 서버는 이를 검증하고 401 에러를 응답한다.

### **Step 4: 인증 상태 갱신**

1. 클라이언트는 401 에러를 받고, 토큰 재발급을 위한 특별한 API 엔드포인트에 리프레시 토큰을 담아 요청을 보낸다
2. 서버는 리프레시 토큰과 서버 DB의 내용을 비교하고 검증한다. 모든 것이 유효하다면 서버는 이 사용자의 인증 상태가 유효하다고 판단하여 새로운 액세스 토큰을 발급하여 클라이언트에게 전달한다.
   - 이때 보안을 위해 새로운 리프레시 토큰을 함께 발급하기도 한다. 이를 Token Rotation이라 한다.

### **Step 5: 로그아웃**

1. 클라이언트는 서버의 로그아웃 엔드포인트(`POST /api/logout`)를 호출하여 로그아웃을 요청한다.
2. 서버는 요청과 함께 온 리프레시 토큰을 확인한다. 그리고 DB에 저장된 리프레시 토큰 중 해당 토큰을 삭제한다. 또한 클라이언트의 리프레시 토큰을 삭제하라는 의미로 `Max-Age=0` 속성을 가진 동일한 이름의 쿠키를 `Set-Cookie` 헤더에 담아 보낸다.
3. 클라이언트는 메모리에 저장하고 있던 엑세스 토큰을 삭제하고 리다이렉션 시킨다.
