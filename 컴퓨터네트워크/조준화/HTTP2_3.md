# HTTP/2, HTTP/3

## 1. HTTP/2

### 등장 배경

HTTP/1.1은 한 번에 하나의 요청만 처리할 수 있는 Head-of-Line (HOL) Blocking이라는 치명적인 문제가 있었다. 예를 들어 용량이 큰 이미지와 같은 특정 요청에 대한 응답이 지연되면 그 뒤의 모든 요청들이 대기해야 하는 것이다.

이를 해결하기 위해 Domain Sharding으로 여러 TCP 연결을 만드는 등의 해결책을 제시했지만 근본적으로 해결할 수 없었다.

### HTTP/2의 핵심 기술

1. **멀티플렉싱 (Multiplexing)**
2. **헤더 압축 (HPACK):** 이전 요청과 중복되는 헤더 정보를 제거하고, 허프만 코딩으로 압축하여 전송 데이터의 크기를 줄인다.

### HTTP/2의 핵심 기술 - 멀티플렉싱 (Multiplexing)

HTTP/1.1과 달리 HTTP/2는 하나의 TCP 연결에 여러 데이터 스트림을 구축하여 한 스트림이 커다란 요청때문에 Blocking 되어도 다른 스트림은 사용할 수 있게 된다.

- **연결(Connection):** 클라이언트와 서버 사이의 단일 TCP 연결
- **스트림(Stream):** 각 요청-응답 쌍
- **프레임(Frame):** 통신의 최소 단위. 요청과 응답 데이터는 잘게 쪼개진 프레임 단위로 전송된다.

HTTP/2에서는 이 프레임들을 순서에 상관없이 마구 섞어서 보내고, 받는 쪽에서 각 프레임에 부여된 스트림 ID를 보고 다시 조립한다. 이 덕분에 하나의 연결만으로도 여러 요청을 동시에 처리할 수 있는 것이다.

### 번외) IO 멀티플렉싱과의 차이

| 구분     | **스트림 멀티플렉싱 (HTTP/2)**          | **IO 멀티플렉싱 (서버 기술)**               |
| -------- | --------------------------------------- | ------------------------------------------- |
| **계층** | **애플리케이션 계층**                   | **운영체제(OS) 커널** 수준의 입출력 모델    |
| **목적** | **하나의 연결 안에서 여러 스트림 관리** | **하나의 스레드가 여러 개의 Socket을 관리** |

예를 들어 Nginx와 같은 웹 서버가 **IO 멀티플렉싱을 사용해서** 수만 개의 클라이언트 **연결을 효율적으로 처리**하고, 그 중 하나의 연결이 HTTP/2 프로토콜을 사용한다면 그 안에서 **스트림 멀티플렉싱이 일어나는 것이다.**

---

## 2. HTTP/3

### 등장 배경

HTTP/2는 애플리케이션 레벨의 HOL Blocking은 해결했지만, 전송 계층인 TCP의 근본적인 HOL Blocking은 해결할 수 없었다. TCP는 패킷의 순서를 엄격하게 보장하기 때문에, 중간에 패킷 하나가 유실되면 복구될 때까지 해당 연결의 모든 스트림이 전부 멈춰버리는 문제가 발생했다.

프레임을 조립하는 과정에서 패킷 유실이 발견되면 모든 스트림이 멈추는 것이다.

### HTTP/3의 핵심 기술: QUIC

이 문제를 해결하기 위해 HTTP/3는 TCP를 버리고 QUIC (Quick UDP Internet Connections)이라는 새로운 프로토콜을 했다.

1. **UDP 기반 프로토콜:** QUIC은 TCP와 달리 패킷 순서를 보장하지 않는 UDP를 기반으로 한다. 대신 QUIC 자체가 스트림별로 패킷 유실을 감지하고 복구하는 기능을 가지고 있다. 따라서 **한 스트림의 패킷이 유실되어도 다른 스트림은 멈추지 않고 계속 데이터를 전송**할 수 있어 TCP의 HOL Blocking 문제를 완벽히 해결했다.
2. **빠른 연결 수립 (0-RTT, 1-RTT):** TCP와 TLS 핸드셰이크 과정을 통합하여 연결에 걸리는 시간을 단축시켰다.
3. **연결 마이그레이션 (Connection Migration):** 사용자가 Wi-Fi에서 LTE로 전환하는 등의 네트워크 환경이 바뀌어도, IP 주소가 아닌 고유한 연결 ID를 기반으로 통신하므로 연결이 끊기지 않고 유지된다.
