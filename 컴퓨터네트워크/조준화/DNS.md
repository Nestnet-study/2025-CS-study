# DNS와 웹 통신 흐름

## 1. DNS 동작 원리

DNS(Domain Name System)은 도메인 이름을 IP 주소로 변환해주는 시스템이다.

가장 첫 단계는 사용자가 도메인 이름을 웹 브라우저를 통해 요청하는 것이다. 이때 다음의 과정이 일어난다.

1. 브라우저 캐시 확인
2. OS 캐시 확인 : 이때 hosts 파일을 확인한다.
3. Resolver에 요청
   - Resolver (Recursive DNS Server)는 컴퓨터에 설정된 DNS 서버이다. 보통 인터넷 서비스 제공업체(ISP)가 제공하는 서버로, SKT DNS가 해당된다.
   - Stub Resolver : 운영체제에 내장되어 있고, 미리 설정된 DNS 서버로 그 질문을 전달하는 역할을 한다.
   - Recursive Resolver : 일반적인 리졸버로 ISP, Google 등이 운영하는 외부 서버이다.

리졸버는 클라이언트 대신 IP 주소를 찾는 역할을 한다. 이때 IP 주소를 찾는 과정에서 Recursive Query, Iterative Query가 사용된다. 각 쿼리의 역할과 차이점은 조금 뒤에 알아보자.

리졸버는 다음의 과정으로 IP 주소를 찾는다.

1. 루트 DNS 서버에 쿼리
   - 루트 DNS 서버는 전 세계에 13개 존재하며, DNS 계층 구조의 최상위에 존재한다.
   - 루트 서버는 도메인의 가장 오른쪽 부분인 `.com`을 관리하는 TLD 서버의 주소를 알려준다.
2. 최상위 도메인(TLD) DNS 서버에 쿼리
   - TLD 서버 역시 도메인의 전체 IP 주소는 알지 못하고, [`google.com`](http://google.com) 도메인을 관리하는 권한 있는 네임서버의 주소를 알려준다.
3. 권한 있는 네임서버에 쿼리
   - 권한 있는 네임서버는 `www.google.com`의 A 레코드를 가지고 있으며, 최종적으로 IP 주소를 리졸버에게 응답한다.
   - A 레코드란 도메인 이름과 IP 주소를 매핑한 정보이다.

이렇게 찾은 IP는 리졸버 캐시에 저장하고 운영체제에 전달한다. 운영체제는 이를 브라우저에게 전달하며 DNS 과정이 끝이 난다.

---

## 2. Recursive Query, Iterative Query

누가 최종 IP 주소를 찾기 위해 여러 서버에 물어보는가에 따라 어떤 쿼리인지 갈린다.

- 재귀적 쿼리 (Recursive Query)
  - **요청자:** 클라이언트
  - **응답자:** Resolver
  - **동작 방식:** 클라이언트가 리졸버에서 도메인 주소를 요청한다. 이후 리졸버는 책임을 가지고 루트 DNS 부터 최종 IP 주소를 찾는 과정까지 모든 과정을 대신 처리한다. 마지막으로 최종 IP 주소만을 클라이언트에게 돌려주는 방식이다.
- 반복적 쿼리 (Iterative Query)
  - **요청자:** Resolver
  - **응답자:** 루트, TLD, 권한 있는 네임서버 등 각 DNS 서버
  - **동작 방식:** 리졸버가 다른 DNS 서버들에게 반복적으로 IP 주소를 물어보는 방식이다. 쿼리를 받은 DNS 서버는 자신이 아는 다음에 가야 할 곳만 알려주고, 리졸버는 이를 바탕으로 다음 DNS 서버에게 물어보는 과정을 반복한다.

여기서 주의할 점이 두 쿼리 중 한 종류만 사용하는 것이 아니라, 클라이언트가 리졸버에게 재귀적 쿼리를 한 번 보내고, 리졸버는 그 요청을 해결하기 위해 반복적 쿼리를 주고받는 것이라는 점이다.

---

## 3. 웹 통신 흐름

내 PC는 `192.168.1.5`라는 사설 IP를 쓰고, 공유기(라우터)를 통해 인터넷에 연결되어 있다고 가정하자. 이때 브라우저에 `google.com`을 입력하면 생기는 복잡한 데이터 교환을 계층별로 뜯어보자.

### 1. 요청 (PC → 구글 서버)

1. **L7: 응용 계층 (Application Layer)**
   1. **DNS 조회:** 이 DNS 요청 또한 L7~L1의 캡슐화 과정을 거친다.
   2. **DNS 응답**
   3. **HTTP 요청 생성:** 이제 브라우저는 알아낸 IP 주소 `172.217.160.78`을 목적지로 하여 HTTP 요청 메시지를 생성한다.
2. **L6: 표현 계층 (Presentation Layer)**
   1. **TLS/SSL 암호화:** HTTPS 요청이므로, TLS 핸드셰이크를 거쳐 암호화된 세션을 만든다. HTTP 메시지를 암호화하는 것이다.
3. **L5: 세션 계층 (Session Layer)**
   1. **세션 수립**
4. **L4: 전송 계층 (Transport Layer)**
   1. **TCP 세그먼트 생성:** 데이터 덩어리를 잘라 TCP 세그먼트로 만든다.
   2. **포트 번호 추가:** 각 세그멘트의 헤더에 송신, 수신 포트 번호를 기록한다.
5. **L3: 네트워크 계층 (Network Layer)**
   1. **IP 패킷 생성:** TCP 세그먼트에 IP 헤더를 붙여 IP 패킷으로 만든다.
   2. **IP 주소 추가:** 헤더에 출발지와 목적지 IP 주소를 기록한다..
6. **L2: 데이터 링크 계층 (Data Link Layer)**
   1. **이더넷 프레임 생성:** IP 패킷에 이더넷 헤더를 붙여 프레임으로 만든다.
   2. **MAC 주소 추가:** 프레임은 로컬 네트워크 내에서 다음 목적지로 가야 한다. 따라서 헤더에 PC와 공유기의 MAC 주소를 기록한다.
      - **ARP (주소 결정 프로토콜):** 이때 PC가 공유기의 MAC 주소를 모른다면 ARP 요청을 브로드캐스트하여 MAC 주소를 알아낸다.

### 2. 공유기 → 구글 서버

1. **NAT (네트워크 주소 변환):** 패킷이 공유기에 도착하면, 공유기는 **NAT**를 수행한다. 외부 인터넷망에서는 사설 IP(`192.168.1.5`)를 쓸 수 없기 때문이다.
   - 공유기는 패킷의 출발지 IP 주소를 자신의 공인 IP 주소로 바꾼다.
   - 이때 어떤 내부 PC의 요청인지 기억하기 위해 포트 번호도 함께 바꾸고, 이 변환 정보를 NAT 테이블에 기록한다.
2. **라우팅:** 이제 패킷은 공인 IP를 달고 수많은 홉들을 거쳐 목적지 IP까지 도달하게 된다.

### 3. 응답 (구글 서버 → PC)

1. **구글 서버 도착 및 역캡슐화:** 구글 서버는 L1부터 L7까지 역순으로 데이터를 해석(역캡슐화)하여 최종적으로 암호화된 HTTP 요청을 확인한다.
2. **응답 데이터 생성 및 캡슐화:** 서버는 요청에 맞는 웹페이지 데이터(HTML, CSS 등)를 담아 HTTP 응답 메시지를 만든다. 그리고 PC에서 했던 것과 똑같이 L7부터 L1까지 캡슐화 과정을 거쳐 응답 패킷을 생성한다.
3. **PC 도착 및 최종 렌더링:** 응답 패킷이 공유기에 도착하면, 공유기는 NAT 테이블을 통해 사설 IP로 목적지를 수정하여 전달한다.
4. PC는 응답 패킷을 L1부터 L7까지 역캡슐화하여 암호화된 데이터를 복호화하고, 렌더링한다.
