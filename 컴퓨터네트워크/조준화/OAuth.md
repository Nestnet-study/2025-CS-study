# OAuth와 소셜 로그인

소셜 로그인은 인증(로그인)을 편리하게 해결하기 위한 수단이며, OAuth는 이 과정의 핵심적인 인가 메커니즘을 제공하는 프레임워크이다. 사용자는 자신의 소셜 비밀번호를 우리의 서비스에 직접 노출하지 않는다. 대신 해당 소셜이 대신 사용자를 증명하고, 우리가 만든 서비스가 사용자의 이름, 이메일 등 정보에 접근할 수 있도록 허가해주는 과정을 OAuth가 담당한다.

---

## 1. OAuth의 구성 요소

OAuth 2.0은 네 가지 주요 역할로 구성된 위임(Delegation) 프로토콜이다. 여기서 위임이라 하면, 인가를 위임한다고 생각하면 된다.

1. **리소스 소유자 (Resource Owner)**
   - 사용자를 의미한다. 자신의 리소스에 대한 소유권을 가진다.
2. **클라이언트 (Client)**
   - 리소스 소유자를 대신하여 리소스에 접근하려는 어플리케이션이다.
   - 사용자의 동의하에 리소스 서버에 접근할 수 있는 액세스 토큰을 발급받아야 한다.
3. **인가 서버 (Authorization Server)**
   - 구글과 같은 클라이언트와 리소스 소유자를 인증하고, 클라이언트에게 액세스 토큰을 발급하는 역할을 한다.
4. **리소스 서버 (Resource Server)**
   - Google API 서버와 같이 리소스 소유자의 정보를 실제로 저장하고 관리하는 서버이다.
   - 클라이언트가 제시한 액세스 토큰을 검증하고 유효한 경우 요청된 리소스를 제공한다.
   - 실제 서버에서는 주로 인가 서버와 리소스 서버가 동일한 서비스에 의해 운영된다.

---

## 2. 소셜 로그인의 동작 원리

소셜 로그인에서는 Authorization Code Grant 방식을 표준으로 사용한다.

### Phase 1 : 인가 코드 발급 요청

1. 사용자가 로그인을 요청하면 클라이언트는 사용자의 브라우저를 구글의 인가 서버로 리다이렉션시킨다. 이때 다음과 같은 쿼리 파라미터가 포함된다.

   ```json
   https://accounts.google.com/o/oauth2/v2/auth?
    client_id=YOUR_CLIENT_ID&
    redirect_uri=https://our-service.com/callback&
    response_type=code&
    scope=openid%20profile%20email&
    state=RANDOM_STRING
   ```

   - redirect_uri : 인가 코드를 받아 처리할 클라이언트의 특정 주소
   - scope : 클라이언트가 사용자에게 요청하는 권한의 범위

2. 사용자는 구글 로그인 페이지를 보고, 동의 화면을 거친다. 해당 과정은 사용자 ↔ 인가 서버로 볼 수 있다.
3. **사용자 ↔ 인가 서버**

### **Phase 2 : 인가 코드 발급 및 클라이언트로 전달**

1. 인가 서버는 일회성 인가 코드를 생성한다. 그 후 사용자의 브라우저를 redirect_uri로 다시 리다이렉션 시킨다. 이때 쿼리 파라미터로 인가 코드를 전달한다. 클라이언트는 state 값을 비교하여 요청이 위조되지 않았는지 검증한다.

### **Phase 3 : 액세스 토큰 발급**

1. 클라이언트는 인가 코드를 사용하여 인가 서버의 토큰 엔드포인트로 POST 요청을 거친다. 이 통신은 사용자를 거치지 않는 클라이언트 ↔ 인가 서버 구조이다.

   ```json
   POST /token HTTP/1.1
   Host: oauth2.googleapis.com
   Content-Type: application/x-www-form-urlencoded

   grant_type=authorization_code&
   code=AUTHORIZATION_CODE&
   redirect_uri=https://our-service.com/callback&
   client_id=YOUR_CLIENT_ID&
   client_secret=YOUR_CLIENT_SECRET
   ```

2. 인가 서버는 클라이언트에게 받은 HTTP 요청을 검증하고, 모든 것이 유효하다면 JSON 형태로 액세스 토큰과 리프레시 토큰을 응답한다.

   ```json
   {
     "access_token": "ACCESS_TOKEN_STRING",
     "token_type": "Bearer",
     "expires_in": 3599,
     "refresh_token": "REFRESH_TOKEN_STRING",
     "scope": "openid profile email"
   }
   ```

### **Phase 4 : 리소스 접근 및 로그인 처리**

1. 클라이언트는 발급받은 액세스 토큰을 사용하여 리소스 서버에 사용자 정보를 요청한다.
2. 리소스 서버는 액세스 토큰의 유효성을 검증하고, 유효하다면 요청된 scope에 맞는 사용자 정보를 응답한다.
3. 이후 자체적인 세션이나 토큰 등을 통해 사용자와 클라이언트(서버)에 대한 로그인 상태를 유지할 수 있다.

---

## 3. OIDC (OpenID Connect): 인증 계층

소셜 로그인은 인가 메커니즘을 인증 목적으로 활용한다. 사용자가 B 서비스에 구글 계정으로 로그인을 시도한다면 B 서비스는 OAuth 절차를 통해 구글에게 사용자의 정보에 접근할 권한을 요청한다.

B 서비스가 사용자의 이메일 주소를 성공적으로 받아왔다면, 즉 인가에 성공했다면 B 서비스의 입장에서는 구글이 사용자에 대한 인증을 이미 했기에 인가를 했다는 뜻이고 추가적인 인증 절차를 거치지 않는 것이다.

하지만 OAuth는 인증 프로토콜이 아닌 인가 프로토콜이다. 따라서 클라이언트는 리소스 서버로부터 사용자의 정보를 받아올 수는 있지만, 인증적 측면이 부족하다. 클라이언트는 리소스 서버로부터 사용자 정보를 받아올 뿐, 사용자가 '누구인지'를 표준화된 방식으로 확인하는 기능은 부족하다는 뜻이다.

이를 보완하는 것이 OAuth 위에 구축된 ID 계층, OIDC(Open ID Connect) 이다.

- **ID 토큰** : OIDC의 핵심으로, 액세스 토큰과 함께 발급되는 JWT이다. 사용자의 식별 정보가 표준화된 형식으로 담겨있다.
- **인증의 증거**: 클라이언트는 ID 토큰의 서명을 검증함으로써 인가 서버가 사용자를 인증했음을 신뢰할 수 있다.
- **요청 방법**: OAuth 요청 시 `scope`에 `openid`를 포함하면 OIDC 요청이 된다. 응답으로 액세스 토큰과 함께 ID 토큰이 발급된다.

### 왜 OIDC인가?

OAuth는 권한은 알려주지만 누구인지는 알려주지 않았다. OIDC가 없을 때는 다음과 같은 추론에 기반하여 소셜 로그인을 구현했다

1. 클라이언트 → 구글의 권한 요청
2. 구글은 액세스 토큰 응답
3. 앱은 그 토큰을 이용해 구글 API를 호출해서 사용자의 이메일을 받아옴
4. 앱은 구글이 정보를 줬으니 사용자의 인증을 믿고 추론하여 사용함

이 방식의 문제점은 다음과 같다.

- 구글, 페이스북, 네이버 등 서비스마다 사용자의 정보를 주는 API 경로, 데이터 형식이 모두 달랐다. 즉 표준이 없었다.
- 오직 인증만을 위해서 불필요한 이메일, 이름 등을 가져오는 API 호출이 추가로 필요했다.
- 액세스 토큰 자체에는 누가 언제 인증받았다와 같은 명시적인 증거, 정보가 없다.

OIDC가 생긴 후 다음과 같이 변화했다.

1. 앱은 인증을 위해 구글에게 `scope = openid` 로 요청
2. 구글은 사용자를 인증했다는 ID 토큰 발급
3. 앱은 추가적인 API 호출 없이 ID 토큰만 검증하면 인증 완료
