# REST API, RESTful, RPC, SOAP

## 1. 아키텍처 스타일과 프로토콜

비교에 앞서, 각 용어의 개념을 명확히 해야 한다.

- **아키텍처 스타일 :** **REST**는 근본적으로 **아키텍처 스타일**이다. 웹과 같은 분산 시스템을 위한 소프트웨어 아키텍쳐의 제약조건의 집합이라 볼 수 있는 것이다. 즉, 어떻게 통신할지에 대한 기술을 지칭하는 것이 아닌, 어떤 구조를 가져갈 것인지에 대한 가이드라인이다.
  - **R**EST는 특정 기술이나 JSON 등의 데이터 포맷에 의존하지 않는 분산 시스템 설계를 위한 제약 조건들의 집합이기에 아키텍쳐 스타일로 볼 수 있다.
- **프로토콜 :** 반면, **SOAP**와 **RPC**는 프로토콜에 더 가깝다. 프로토콜은 통신을 위한 메시지의 형식과 순서, 그리고 메시지를 주고받을 때 수행해야 할 동작을 정의한 규칙의 집합이다.

---

## 2. REST vs RESTful

- **REST API:** 넓은 의미에서 HTTP 프로토콜을 사용하여 CRUD 기능을 제공하는 API를 지칭하는 경우가 많다. URI가 자원을 표현하고 HTTP 메서드를 사용하는 것만으로도 REST API라고 부르기도 한다.
- **RESTful API:** REST 아키텍처 스타일의 제약 조건을 충실히 따르는 API를 의미한다. 이는 단순한 CRUD 연동을 넘어 다음의 핵심 제약 조건을 모두 만족해야 한다.
  1. **클라이언트-서버 구조**
  2. **무상태 (Stateless):** 서버는 클라이언트의 컨텍스트를 저장하지 않는다. 모든 요청은 그 자체로 완전한 정보를 담고 있어야 한다.
  3. **캐시 가능 (Cacheable):** HTTP의 캐싱 메커니즘(ETag, Cache-Control 등)을 그대로 활용하여 성능을 향상시킬 수 있어야 한다.
  4. **계층화 시스템 (Layered System):** 클라이언트는 최종 서버에 직접 연결되었는지, 중간의 프록시나 게이트웨이를 거치는지 알 수 없다.
  5. **균일한 인터페이스 (Uniform Interface)**
     - **자원의 식별 (Identification of resources):** URI를 통해 자원을 유일하게 식별한다.
     - **표현을 통한 자원 조작 (Manipulation of resources through representations):** 클라이언트는 자원의 표현을 받아 상태를 파악하고, 이 표현을 수정하여 서버에 보내는 것으로 자원의 상태를 변경한다.
     - **자기 서술적 메시지 (Self-descriptive messages):** 메시지는 스스로를 설명할 수 있어야 한다 (e.g., `Content-Type` 헤더로 미디어 타입 명시).
     - **HATEOAS (Hypermedia as the Engine of Application State):** 애플리케이션의 상태는 하이퍼미디어를 통해 전이되어야 한다. 즉, 응답에 다음 행동을 할 수 있는 URI 링크가 포함되어, 클라이언트는 이를 통해 동적으로 서비스와 상호작용할 수 있다.

---

## 3. RPC

RPC는 원격의 프로시저를 로컬에 있는 것처럼 호출한다는 아이디어에서 출발한다. 개발자는 소켓 프로그래밍과 같은 네트워크 통신을 신경 쓸 필요 없이 로컬 함수를 쓰듯 비즈니스 로직에만 집중할 수 있다.

- **동작 원리:**
  1. **IDL(Interface Definition Language):** `.proto`(Protocol Buffers)나 `.thrift`(Apache Thrift) 같은 IDL 파일을 사용하여 서버가 제공하는 서비스, 함수, 매개변수, 반환 값의 타입을 정의한다.
  2. **Stub/Skeleton 생성:** IDL 컴파일러는 클라이언트 측의 **Stub**과 서버 측의 **Skeleton** 코드를 특정 프로그래밍 언어에 맞게 자동으로 생성한다.
  3. **호출:** 클라이언트는 생성된 Stub 객체의 메서드를 호출한다.
  4. **Marshalling & Unmarshalling:** Stub은 메서드 호출과 인자들을 바이너리와 같은 포맷으로 직렬화(Marshalling)하여 네트워크를 통해 서버로 전송한다. 서버의 Skeleton은 이 데이터를 받아 역직렬화(Unmarshalling)하여 실제 로직을 수행하는 함수를 호출한다.
  5. **응답:** 서버는 결과를 다시 직렬화하여 클라이언트에 보내고, 클라이언트의 Stub은 이를 역직렬화하여 최종 반환 값으로 클라이언트 애플리케이션에 전달한다.

**gRPC (Google RPC):** 현대적인 RPC 구현체 중 가장 대표적인 것이 gRPC이다. HTTP/2를 기반으로 하여 다음과 같은 강력한 기능을 제공한다.

- **Protocol Buffers:** 고성능의 바이너리 직렬화 포맷을 사용하여 JSON이나 XML보다 훨씬 작고 빠른 데이터 교환이 가능하다.
- **스트리밍(Streaming):** 단일 요청-응답 모델을 넘어 서버 스트리밍, 클라이언트 스트리밍, 양방향 스트리밍을 지원하여 실시간 통신이나 대용량 데이터 전송에 유리하다.
- **엄격한 타입 체크:** IDL을 통해 컴파일 시점에 타입 오류를 잡을 수 있어 안정성이 높다.

이러한 특징 덕분에 RPC, 특히 gRPC는 내부 마이크로서비스 간의 통신에서 많이 사용된다.

---

## 4. SOAP

SOAP는 분산 환경에서 구조화된 정보를 교환하기 위한 XML 기반의 프로토콜이다.

- **구조:** 모든 SOAP 메시지는 **Envelope**이라는 XML 구조 안에 담긴다.
  - **Header (Optional):** 인증, 트랜잭션 ID, 라우팅 정보 등 메타데이터를 담는다. SOAP의 확장성을 책임지는 부분이다.
  - **Body:** 실제 요청/응답 메시지 본문을 담는다.
  - **Fault (Optional, in Body):** 에러가 발생했을 때의 정보를 담는 표준화된 구조를 제공한다.
- **WSDL (Web Services Description Language):** SOAP 기반 웹 서비스는 반드시 WSDL이라는 XML 형식의 문서로 서비스를 명세해야 한다. WSDL에는 서비스가 제공하는 기능(Operations), 메시지 형식, 데이터 타입, 그리고 서비스 엔드포인트(주소)에 대한 모든 정보가 담겨있다. 클라이언트는 WSDL을 파싱하여 서버와 통신하는 코드를 자동으로 생성할 수 있다.
- **장단점:**
  - **장점:**
    - **표준 기반:** W3C 표준으로 플랫폼과 언어에 독립적이다.
    - **강력한 확장성:** WS-Security, WS-AtomicTransaction 등 다양한 WS-\* 표준을 조합하여 원하는 수준의 보안과 신뢰성을 확보할 수 있다.
    - **전송 프로토콜 독립성:** HTTP뿐만 아니라 SMTP, TCP 등 다양한 프로토콜 위에서 동작할 수 있다.
  - **단점:**
    - **복잡성:** XML 자체의 장황함과 WSDL, WS-\* 표준들의 복잡도로 인해 학습 곡선이 가파르고 개발 생산성이 낮다.
    - **성능:** XML 파싱/생성에 드는 비용과 메시지 크기 때문에 REST나 RPC에 비해 성능이 떨어진다.

SOAP는 레거시 시스템 연동이나, 은행, 공공기관 등 강력한 보안과 트랜잭션 보장이 필수적인 엔터프라이즈 환경에서 여전히 사용되고 있다.

---

## 5. REST vs RPC vs SOAP

| 상황                                                                     | 추천 아키텍처/프로토콜             | 이유                                                                                                                                                                                                 |
| ------------------------------------------------------------------------ | ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **공개 API, 웹/모바일 클라이언트 연동**                                  | **RESTful API**                    | HTTP 표준을 최대한 활용하여 범용성이 높고, JSON을 통해 가볍고 가독성 좋은 데이터 교환이 가능하다. 브라우저, 모바일 앱 등 다양한 클라이언트에서 쉽게 연동할 수 있다.                                  |
| **내부 마이크로서비스 간의 통신**                                        | **RPC (특히 gRPC)**                | 성능이 매우 중요한 내부망 통신에 최적화되어 있다. 바이너리 프로토콜과 HTTP/2를 통한 낮은 지연 시간과 높은 처리량을 보장하며, IDL을 통해 서비스 간의 명확한 계약을 강제할 수 있다.                    |
| **금융, 공공 등 높은 보안과 트랜잭션 보장이 필요한 엔터프라이즈 시스템** | **SOAP**                           | WS-Security, WS-AtomicTransaction 등 검증된 표준을 통해 복잡한 비즈니스 로직과 데이터의 무결성, 보안을 강력하게 보장해야 할 때 적합하다.                                                             |
| **간단한 동작 수행, CRUD에 맞지 않는 연산**                              | **RPC 또는 REST(동사형 URI 사용)** | 자원으로 표현하기 애매한 '동작' (e.g., `/users/1/sendMessage`)을 수행해야 할 때, RPC는 자연스럽다. REST에서도 동사를 포함한 URI를 사용하는 방식으로 해결할 수 있으나, RPC 방식이 더 직관적일 수 있다 |
