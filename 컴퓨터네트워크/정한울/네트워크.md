# 네트워크

---

# OSI 7계층 vs TCP/IP 4계층

## OSI 7계층 모델

OSI 7계층 모델은 ISO(국제 표준화 기구)에서 제안한 통신 모델로, 통신 과정을 7개의 독립적인 계층으로 나누어 표준화했습니다. 이는 네트워크 통신의 이론적인 틀을 제공하며, 각 계층의 역할을 명확히 정의하여 문제 해결 및 확장에 용이하도록 합니다.

| 계층 번호 | 계층 이름 (Layer Name) | 주요 역할 (Key Role) | PDU (Protocol Data Unit) |
| --- | --- | --- | --- |
| 7 | **응용 계층** (Application Layer) | 사용자에게 네트워크 서비스 제공 (e.g., 웹 브라우징, 이메일, 파일 전송) | 메시지 (Message) |
| 6 | **표현 계층** (Presentation Layer) | 데이터 형식 변환, 압축, 암호화/복호화 (표준화된 방식으로 데이터를 표현) | 메시지 (Message) |
| 5 | **세션 계층** (Session Layer) | 통신 세션 설정, 유지, 종료 및 동기화 | 메시지 (Message) |
| 4 | **전송 계층** (Transport Layer) | 종단 간(End-to-End)의 신뢰성 있는 데이터 전송 보장 (흐름 제어, 오류 제어) | 세그먼트 (Segment - TCP), 데이터그램 (Datagram - UDP) |
| 3 | **네트워크 계층** (Network Layer) | IP 주소를 사용하여 데이터 패킷을 목적지까지 라우팅 (경로 설정) | 패킷 (Packet) |
| 2 | **데이터 링크 계층** (Data Link Layer) | 물리적 주소(MAC 주소)를 사용하여 인접 노드 간 신뢰성 있는 프레임 전송 (오류 감지, 흐름 제어) | 프레임 (Frame) |
| 1 | **물리 계층** (Physical Layer) | 비트 스트림을 물리적 매체(케이블, 전파 등)를 통해 전송 (전기적, 기계적 특성 정의) | 비트 (Bit) |

**PDU (Protocol Data Unit):** 각 계층에서 처리되는 데이터 단위를 의미합니다. 상위 계층에서 받은 데이터를 자신의 계층에 맞는 헤더(제어 정보)와 결합하여 하위 계층으로 전달합니다.

## TCP/IP 4계층 모델

TCP/IP 모델은 실제 인터넷에서 사용되는 표준 프로토콜 스택으로, OSI 모델보다 간소화된 4개의 계층으로 구성됩니다. 이는 실용성에 중점을 두어 설계되었으며, 오늘날의 인터넷 통신의 기반이 됩니다.

| 계층 번호 | 계층 이름 (Layer Name) | OSI 7계층과의 매핑 | 주요 역할 (Key Role) | PDU (Protocol Data Unit) |
| --- | --- | --- | --- | --- |
| 4 | **응용 계층** (Application Layer) | 응용, 표현, 세션 계층 | 사용자 응용 프로그램에 네트워크 서비스 제공 (HTTP, FTP, SMTP, DNS 등) | 메시지 (Message) |
| 3 | **전송 계층** (Transport Layer) | 전송 계층 | 종단 간 통신 및 데이터 신뢰성 보장 (TCP, UDP) | 세그먼트 (Segment - TCP), 데이터그램 (Datagram - UDP) |
| 2 | **인터넷 계층** (Internet Layer) | 네트워크 계층 | IP 주소를 통한 패킷 라우팅 및 경로 설정 (IP, ICMP, ARP 등) | 패킷 (Packet) |
| 1 | **네트워크 접근 계층** (Network Access Layer) | 데이터 링크, 물리 계층 | 물리적 네트워크를 통해 데이터 프레임 전송 (MAC 주소, 이더넷, Wi-Fi 등) | 프레임 (Frame - 데이터 링크), 비트 (Bit - 물리) |

## OSI 7계층 vs TCP/IP 4계층 비교

- **OSI 7계층:**
    - **장점:** 계층별 기능이 명확하게 구분되어 있어, 문제 발생 시 어느 계층에서 문제가 발생했는지 파악하기 용이하며, 각 계층의 독립성이 높아 새로운 기술 도입 및 확장이 용이합니다. 이론적인 모델로, 교육 및 표준화에 주로 사용됩니다.
    - **단점:** 너무 세분화되어 있어 실제 구현에서는 비효율적인 측면이 있습니다.
- **TCP/IP 4계층:**
    - **장점:** 실제 인터넷 환경에서 동작하는 프로토콜 스택으로, 실용성과 효율성에 중점을 둡니다. 비교적 간소화된 구조로 구현이 용이하며 널리 사용됩니다.
    - **단점:** OSI 모델처럼 각 계층의 기능이 명확하게 분리되어 있지 않아 계층 간 경계가 모호한 부분이 있습니다.

두 모델 모두 네트워크 통신의 복잡성을 추상화하여 이해도를 높이는 데 기여하지만, OSI 모델은 통신 설계의 이론적 기반을, TCP/IP 모델은 실제 인터넷 통신의 구현 방식을 보여주는 데 더 중점을 둡니다.

---

# TCP와 UDP

## TCP (Transmission Control Protocol)

TCP는 **연결 지향(Connection-Oriented)** 프로토콜로, 데이터를 보내기 전에 송신자와 수신자 사이에 논리적인 연결을 설정하고 데이터를 주고받은 후 연결을 해제합니다. 이 과정은 **3-way Handshaking**으로 연결을 설정하고, **4-way Handshaking**으로 연결을 해제합니다. TCP는 데이터의 **신뢰성**과 **순서 보장**을 최우선으로 합니다.

**1. 주요 특징:**

- **연결 지향:** 통신 전에 연결 설정(3-way Handshaking) 및 해제(4-way Handshaking) 과정이 있습니다.
- **신뢰성 보장:**
    - **오류 제어 (Error Control):** 손실되거나 손상된 패킷을 재전송하여 데이터의 무결성을 보장합니다. `ACK(Acknowledgement)` 번호를 통해 수신 확인을 합니다.
    - **흐름 제어 (Flow Control):** 송신자가 수신자의 처리 속도보다 빠르게 데이터를 보내는 것을 방지하여 수신 버퍼 오버플로우를 막습니다. `Window Size` 필드를 통해 수신 가능한 버퍼 크기를 알립니다.
    - **혼잡 제어 (Congestion Control):** 네트워크의 혼잡을 감지하고 데이터 전송 속도를 조절하여 네트워크 과부하를 방지합니다.
- **순서 보장:** `Sequence Number`를 통해 패킷의 순서를 보장하고, 순서가 뒤바뀌어 도착해도 올바르게 재조립합니다.
- **1:1 통신 (Unicast):** 한 번에 하나의 송신자와 하나의 수신자 간에 통신이 이루어집니다.
- **느린 속도:** 신뢰성 및 흐름/혼잡 제어 메커니즘으로 인해 UDP보다 전송 속도가 느립니다.
- **전이중 (Full-Duplex):** 양방향으로 동시에 데이터 전송이 가능합니다.

2. **헤더 구조** (최소 20바이트):

TCP 헤더는 최소 20바이트로 구성되며, 옵션 필드에 따라 최대 60바이트까지 확장될 수 있습니다.

- **Source Port (16비트):** 출발지 포트 번호
- **Destination Port (16비트):** 목적지 포트 번호
- **Sequence Number (32비트):** 송신하는 데이터 바이트의 순서 번호. 데이터 조립 및 재전송에 사용됩니다.
- **Acknowledgment Number (32비트):** 수신자가 다음에 받기를 기대하는 바이트의 순서 번호. 수신 확인에 사용됩니다.
- **Data Offset / Header Length (4비트):** TCP 헤더의 길이를 32비트 워드 단위로 나타냅니다. (최소 5, 최대 15)
- **Reserved (6비트):** 미래를 위해 예약된 필드 (현재 0)
- **Control Flags (6비트):** TCP 연결 설정 및 제어에 사용되는 플래그 비트들
    - **URG (Urgent Pointer):** 긴급 데이터 존재 여부
    - **ACK (Acknowledgement):** 확인 응답 번호 필드가 유효함을 나타냄
    - **PSH (Push Function):** 버퍼링 없이 즉시 상위 계층으로 데이터를 전달하도록 요청
    - **RST (Reset the connection):** 연결 강제 초기화 (오류 발생 시)
    - **SYN (Synchronize Sequence Number):** 연결 설정 요청 (3-way Handshaking의 첫 단계)
    - **FIN (No more data from sender):** 연결 해제 요청 (4-way Handshaking의 첫 단계)
- **Window Size (16비트):** 수신 가능한 버퍼의 크기 (흐름 제어에 사용)
- **Checksum (16비트):** 헤더와 데이터를 포함한 오류 검출. 데이터 무결성 검증.
- **Urgent Pointer (16비트):** URG 플래그가 설정되었을 때 긴급 데이터의 끝을 나타내는 오프셋
- **Options (가변):** 선택 사항으로, 추가 기능을 제공 (e.g., 최대 세그먼트 크기 - MSS)
- **Padding (가변):** Options 필드와 함께 TCP 헤더 길이를 32비트의 배수로 맞추기 위함.

## UDP (User Datagram Protocol)

UDP는 **비연결형(Connectionless)** 프로토콜로, 데이터를 보내기 전에 연결 설정 과정이 없습니다. 데이터를 '데이터그램'이라는 단위로 목적지에 전송하며, 데이터의 신뢰성이나 순서 보장을 하지 않습니다.

**1. 주요 특징:**

- **비연결형:** 통신 전에 별도의 연결 설정 및 해제 과정이 없습니다.
- **신뢰성 보장 없음:**
    - 오류 제어, 흐름 제어, 혼잡 제어 기능이 없습니다.
    - 데이터 손실이나 순서 변경에 대해 재전송 또는 보장하지 않습니다.
    - `Checksum` 필드를 통해 최소한의 오류만 검출하며, 이는 선택 사항입니다.
- **순서 보장 없음:** 패킷이 독립적으로 전송되므로, 도착 순서가 뒤바뀔 수 있습니다.
- **1:1 (Unicast), 1:N (Multicast), N:N (Broadcast) 통신 가능:** 다양한 통신 방식을 지원합니다.
- **빠른 속도:** 연결 설정 및 신뢰성 메커니즘이 없으므로 TCP보다 전송 속도가 빠르고 네트워크 부하가 적습니다.
- **오버헤드가 낮음:** 헤더가 매우 간단하여 처리할 정보가 적습니다.

2. **헤더 구조** (고정 8바이트):

UDP 헤더는 매우 간단하며, 고정된 8바이트로 구성됩니다.

- **Source Port (16비트):** 출발지 포트 번호 (선택 사항, 0일 수 있음)
- **Destination Port (16비트):** 목적지 포트 번호
- **Length (16비트):** UDP 헤더와 데이터를 포함한 전체 UDP 데이터그램의 길이 (바이트 단위)
- **Checksum (16비트):** UDP 헤더와 데이터를 포함한 오류 검출 (선택 사항, 0일 수 있음)

## TCP와 UDP의 주요 차이점

| 특징 | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
| --- | --- | --- |
| **연결 방식** | 연결 지향 (Connection-Oriented) | 비연결형 (Connectionless) |
| **신뢰성** | 높음 (오류 제어, 재전송, 수신 확인) | 낮음 (오류 발생 시 재전송 없음) |
| **속도** | 느림 (오버헤드 및 제어 기능 때문) | 빠름 (오버헤드 및 제어 기능 없음) |
| **순서 보장** | 보장함 | 보장하지 않음 (패킷 도착 순서 바뀔 수 있음) |
| **흐름/혼잡 제어** | 있음 | 없음 |
| **통신 방식** | 1:1 통신 (Unicast) | 1:1 (Unicast), 1:N (Multicast), N:N (Broadcast) 가능 |
| **PDU** | 세그먼트 (Segment) | 데이터그램 (Datagram) |
| **헤더 크기** | 최소 20바이트 (가변) | 8바이트 (고정) |
| **사용 사례** | 웹 브라우징 (HTTP), 파일 전송 (FTP), 이메일 (SMTP), 안전한 데이터 전송이 필요한 서비스 | 실시간 스트리밍, 온라인 게임, VoIP, DNS, 빠른 응답이 중요한 서비스 |

---

# TCP 연결 및 해제 과정

TCP는 신뢰성 있는 데이터 전송을 위해 통신을 시작하기 전에 논리적인 '연결'을 설정하고, 통신이 끝난 후에는 '연결'을 해제하는 과정을 거칩니다. 이 과정은 TCP 헤더의 **Control Flags**를 사용하여 제어됩니다.

## TCP 연결 설정: 3-Way Handshake (3단계 악수)

3-Way Handshake는 클라이언트와 서버 간에 데이터 통신을 위한 논리적인 연결을 설정하는 과정입니다. 양측이 데이터를 주고받을 준비가 되었음을 확인하고, 초기 시퀀스 번호(Initial Sequence Number, ISN)를 동기화하는 목적을 가집니다.

**과정:**

1. **[클라이언트 → 서버] SYN (Synchronize Sequence Number)**
    - 클라이언트가 서버에 연결을 요청하기 위해 `SYN` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 이때 클라이언트는 자신의 초기 시퀀스 번호(Client ISN: `x`)를 함께 보냅니다.
    - 클라이언트는 `SYN_SENT` 상태로 전환됩니다.
2. **[서버 → 클라이언트] SYN + ACK (Acknowledgement)**
    - 서버는 클라이언트의 `SYN` 요청을 받고, 연결을 수락한다는 의미로 `SYN` 플래그와 `ACK` 플래그를 모두 1로 설정한 세그먼트를 보냅니다.
    - 서버는 자신의 초기 시퀀스 번호(Server ISN: `y`)를 함께 보냅니다.
    - 클라이언트의 `SYN`에 대한 응답으로, 클라이언트의 초기 시퀀스 번호 `x`에 1을 더한 값(`x+1`)을 `Acknowledgement Number` 필드에 담아 보냅니다. 이는 "나는 `x`까지 잘 받았고, 이제 `x+1`부터 받을 준비가 되었다"는 의미입니다.
    - 서버는 `SYN_RCVD` 상태로 전환됩니다.
3. **[클라이언트 → 서버] ACK**
    - 클라이언트는 서버의 `SYN+ACK` 응답을 받고, 이를 확인했다는 의미로 `ACK` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 서버의 초기 시퀀스 번호 `y`에 1을 더한 값(`y+1`)을 `Acknowledgement Number` 필드에 담아 보냅니다. 이는 "나는 `y`까지 잘 받았고, 이제 `y+1`부터 받을 준비가 되었다"는 의미입니다.
    - 이 `ACK` 세그먼트에는 실제 데이터가 포함될 수도 있습니다.
    - 클라이언트는 `ESTABLISHED` 상태로 전환됩니다.
    - 서버는 클라이언트의 `ACK`를 받으면 `ESTABLISHED` 상태로 전환됩니다.

**목적:**

- 양쪽 모두 통신할 준비가 되었음을 확인합니다.
- 각자의 초기 시퀀스 번호를 교환하고 동기화하여, 이후 데이터 전송 시 순서 보장 및 재조립을 위한 기준을 마련합니다.
- 클라이언트와 서버 모두 데이터를 보내고 받을 준비가 된 `ESTABLISHED` 상태가 됩니다.

## TCP 연결 해제: 4-Way Handshake (4단계 악수)

4-Way Handshake는 연결된 TCP 세션을 안전하게 종료하는 과정입니다. 양쪽 모두 더 이상 보낼 데이터가 없음을 알리고, 남아있는 데이터를 모두 처리한 후 연결을 완전히 닫습니다. TCP는 전이중(Full-Duplex) 통신이므로, 한쪽이 연결을 종료하더라도 다른 쪽은 데이터를 계속 보낼 수 있기 때문에 4단계가 필요합니다.

**과정:**

1. **[클라이언트 → 서버] FIN (Finish)**
    - 클라이언트가 더 이상 서버로 보낼 데이터가 없음을 알리고 연결을 종료하겠다는 의미로 `FIN` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 클라이언트는 `FIN_WAIT_1` 상태로 전환됩니다.
2. **[서버 → 클라이언트] ACK**
    - 서버는 클라이언트의 `FIN` 요청을 받고, 이를 확인했다는 의미로 `ACK` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 클라이언트의 `FIN`에 대한 응답으로, 클라이언트의 마지막 시퀀스 번호에 1을 더한 값(`x+1`)을 `Acknowledgement Number` 필드에 담아 보냅니다.
    - 서버는 `CLOSE_WAIT` 상태로 전환됩니다. 이 상태에서 서버는 아직 클라이언트로 보낼 데이터가 남아있을 수 있으므로, 해당 데이터를 모두 보낼 때까지 기다립니다.
3. **[서버 → 클라이언트] FIN**
    - 서버가 클라이언트로 보낼 모든 데이터를 전송 완료하고, 자신도 이제 연결을 종료하겠다는 의미로 `FIN` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 서버는 `LAST_ACK` 상태로 전환됩니다.
4. **[클라이언트 → 서버] ACK**
    - 클라이언트는 서버의 `FIN` 요청을 받고, 이를 확인했다는 의미로 `ACK` 플래그를 1로 설정한 세그먼트를 보냅니다.
    - 서버의 `FIN`에 대한 응답으로, 서버의 마지막 시퀀스 번호에 1을 더한 값(`y+1`)을 `Acknowledgement Number` 필드에 담아 보냅니다.
    - 클라이언트는 `TIME_WAIT` 상태로 전환됩니다. 이 상태는 일정 시간(보통 2MSL, Maximum Segment Lifetime) 동안 유지되며, 이는 혹시라도 마지막 `ACK`가 손실되었을 경우 서버가 `FIN`을 재전송할 수 있도록 기다려주는 역할을 합니다. 이 시간 동안 동일한 포트 번호를 사용하는 새로운 연결이 생성되는 것을 방지하기도 합니다.
    - 서버는 클라이언트의 마지막 `ACK`를 받으면 `CLOSED` 상태로 전환됩니다.
    - `TIME_WAIT` 시간이 지나면 클라이언트도 `CLOSED` 상태로 전환됩니다.

**목적:**

- 양쪽 모두 더 이상 보낼 데이터가 없음을 확인합니다.
- 남아있는 모든 데이터를 안전하게 전송하고 수신합니다.
- 연결과 관련된 모든 자원(포트, 버퍼 등)을 해제하여 다른 통신에 사용할 수 있도록 합니다.

---

# 네트워크 기기

## 스위치 (Switch)

스위치는 LAN(Local Area Network) 환경에서 **동일한 네트워크 세그먼트 내의 장치들 간에 데이터를 효율적으로 전달**하는 장비입니다.

- **주요 역할:**
    - **MAC 주소 기반 프레임 전달:** 스위치는 학습된 MAC 주소 테이블(CAM 테이블 또는 MAC Address Table)을 기반으로 수신된 데이터 프레임을 목적지 장치(정확한 포트)로만 전달합니다.
    - **충돌 도메인 분할:** 각 포트마다 독립적인 충돌 도메인을 생성하여, 허브에서 발생하던 충돌 문제를 해결하고 네트워크 효율성을 높입니다.
    - **브로드캐스트 도메인:** 기본적으로는 하나의 브로드캐스트 도메인에 속합니다. (L3 스위치나 VLAN을 사용하면 브로드캐스트 도메인도 분할 가능)
- **동작 계층:** **OSI 7계층 중 2계층 (데이터 링크 계층)**에서 주로 동작합니다. (레이어 2 스위치)
    - 최근에는 3계층(네트워크 계층) 기능까지 지원하는 **L3 스위치**도 많이 사용됩니다. L3 스위치는 라우팅 기능도 일부 수행할 수 있습니다.
- **PDU (Protocol Data Unit):** **프레임(Frame)**
- **특징:**
    - 허브와 달리 불필요한 포트로 데이터를 보내지 않아 효율적입니다.
    - 네트워크 성능 향상에 기여합니다.
    - 보통 이더넷(Ethernet) 환경에서 사용됩니다.

## 라우터 (Router)

라우터는 **서로 다른 네트워크(IP 주소 대역) 간에 데이터 패킷을 전달하고 최적의 경로를 결정**하는 장비입니다. 인터넷이 동작하는 핵심 장비라고 할 수 있습니다.

- **주요 역할:**
    - **IP 주소 기반 패킷 포워딩 및 라우팅:** 목적지 IP 주소를 확인하여 가장 효율적인 경로를 통해 다음 홉(next hop) 라우터나 목적지 네트워크로 패킷을 전달합니다.
    - **네트워크 간 연결:** LAN과 LAN, LAN과 WAN(Wide Area Network), 서로 다른 IP 대역의 네트워크를 연결합니다.
    - **브로드캐스트 도메인 분할:** 라우터의 각 인터페이스는 별도의 브로드캐스트 도메인을 형성합니다.
- **동작 계층:** **OSI 7계층 중 3계층 (네트워크 계층)**에서 동작합니다.
- **PDU (Protocol Data Unit):** **패킷(Packet)**
- **특징:**
    - IP 주소를 기반으로 동작하며, 라우팅 테이블을 사용하여 경로를 결정합니다.
    - 네트워크 계층 주소(IP 주소)를 변경하지 않고 패킷을 전달합니다. (TTL 값은 변경)
    - 데이터 패킷이 지나갈 때마다 헤더 정보를 읽고 경로를 계산하여 전달하므로 스위치보다 상대적으로 느릴 수 있습니다.

## 게이트웨이 (Gateway)

게이트웨이는 **서로 다른 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 해주는 장비 또는 소프트웨어 기능**을 통칭하는 포괄적인 개념입니다.

- **주요 역할:**
    - **프로토콜 변환:** 완전히 다른 통신 프로토콜이나 데이터 형식을 사용하는 네트워크 사이에서 번역기 역할을 하여 데이터를 상호 이해할 수 있도록 변환합니다.
    - **네트워크 경계:** 한 네트워크에서 다른 네트워크로 나가는 '문' 역할을 합니다. 특히 로컬 네트워크에서 인터넷으로 나갈 때 사용되는 라우터는 게이트웨이의 한 종류(기본 게이트웨이)로 볼 수 있습니다.
    - **데이터 형식 변환:** 데이터 압축/해제, 암호화/복호화 등 더 높은 계층의 서비스도 포함할 수 있습니다.
- **동작 계층:** **OSI 7계층 전 계층**에서 동작할 수 있습니다. (특히 4계층 이상, 즉 전송 계층부터 응용 계층까지의 프로토콜 변환에 특화)
    - 가장 일반적으로 접하는 게이트웨이는 라우터가 기본 게이트웨이 역할을 하는 경우인데, 이 경우는 3계층에서 작동하는 게이트웨이의 한 예시입니다. 하지만 이메일 게이트웨이, 음성 게이트웨이 등은 더 높은 계층에서 작동합니다.
- **PDU (Protocol Data Unit):** 특별히 정해진 PDU는 없으며, 상황에 따라 **메시지, 세그먼트, 패킷, 프레임** 등 다양한 PDU를 처리하고 변환할 수 있습니다.
- **특징:**
    - `기본 게이트웨이 (Default Gateway)`: 로컬 네트워크에 속하지 않은 IP 주소로 데이터를 보낼 때, 패킷을 전달하는 첫 번째 라우터를 의미합니다. 우리가 흔히 '게이트웨이 주소'라고 부르는 것이 이 기본 게이트웨이의 IP 주소입니다.
    - 광범위한 의미로 사용되며, 단순한 하드웨어 장비뿐 아니라 소프트웨어적인 기능이나 서비스도 게이트웨이라고 불릴 수 있습니다. 예를 들어, API Gateway는 마이크로서비스 간의 통신을 중재하는 소프트웨어 게이트웨이입니다.

## 요약 및 비교

| 특징 | 스위치 (Switch) | 라우터 (Router) | 게이트웨이 (Gateway) |
| --- | --- | --- | --- |
| **주요 역할** | 동일 네트워크 내 효율적 데이터 전달 | 서로 다른 네트워크 간 패킷 라우팅 및 경로 결정 | 다른 프로토콜/네트워크 간 통신 연결 및 변환 |
| **동작 계층** | **OSI 2계층 (데이터 링크)** 주로 | **OSI 3계층 (네트워크)** | **OSI 전 계층** (주로 4계층 이상) |
| **주소 유형** | MAC 주소 | IP 주소 | IP 주소 및 그 이상의 계층 주소/프로토콜 |
| **분할** | 충돌 도메인 분할 (브로드캐스트 도메인은 아님) | 브로드캐스트 도메인 분할 | 프로토콜/네트워크 경계 형성 |
| **PDU** | 프레임 (Frame) | 패킷 (Packet) | 상황에 따라 다름 (메시지, 세그먼트, 패킷 등) |
| **예시** | 이더넷 스위치 | 인터넷 라우터, 무선 라우터 | 기본 게이트웨이 (라우터), 이메일/VoIP 게이트웨이, API Gateway |

---

# IP와 주소 체계

---

# DNS (Domain Name System)

## DNS란?

- **인터넷의 전화번호부:** 사람이 읽기 쉬운 **도메인 이름** (예: `google.com`)을 컴퓨터가 이해하는 **IP 주소** (예: `172.217.160.142`)로 변환해주는 시스템.

## DNS 동작 원리 (계층 구조)

DNS는 분산된 계층적 데이터베이스 시스템입니다.

- **DNS 클라이언트 (Stub Resolver):** 사용자의 PC/장치.
- **Recursive DNS Server (DNS Resolver):** ISP 제공 또는 공용 서버 (예: 8.8.8.8). 클라이언트의 쿼리를 대신 처리하며, 다른 DNS 서버들에게 최종 IP를 찾아냄.
- **Root Name Server:** 최상위 서버. TLD 서버 주소 알려줌.
- **TLD Name Server (Top-Level Domain):** `.com`, `.kr` 등 최상위 도메인 관리. 해당 도메인의 Authoritative 서버 주소 알려줌.
- **Authoritative Name Server:** 특정 도메인의 실제 IP 주소 등 최종 정보를 보유.

## DNS 쿼리 유형

### 1) Recursive Query (재귀적 질의)

- **누가 누구에게:** **클라이언트** ➡️ **로컬 DNS 서버(Recursive Resolver)**
- **무엇을 기대하는가:** 로컬 DNS 서버가 **최종 IP 주소를 직접 찾아서 응답**해줄 것을 기대. (모든 과정을 위임)
- **비유:** "이 책을 찾아주세요. 사서님이 다 찾아주세요."

### 2) Iterative Query (반복적 질의)

- **누가 누구에게:** **로컬 DNS 서버(Recursive Resolver)** ➡️ **다른 DNS 서버들 (Root, TLD, Authoritative)**
- **무엇을 기대하는가:** 질의받은 서버가 자신이 아는 **최선의 정보(다음으로 물어볼 서버의 주소)**를 알려줄 것을 기대. (다음 단계를 직접 찾아야 함)
- **비유:** "이 책 어디 있어요? (사서) 저쪽 섹션에 있을 거예요." (직접 가서 찾아야 함)

## 전체 쿼리 과정 흐름

1. **클라이언트** ➡️ **로컬 DNS 서버**: **Recursive Query** (최종 IP 주세요)
2. **로컬 DNS 서버** ➡️ **Root 서버**: **Iterative Query** (`.com` TLD 서버 주소 획득)
3. **로컬 DNS 서버** ➡️ **TLD (.com) 서버**: **Iterative Query** (`example.com` Authoritative 서버 주소 획득)
4. **로컬 DNS 서버** ➡️ **Authoritative (example.com) 서버**: **Iterative Query** (최종 IP 주소 획득)
5. **로컬 DNS 서버** ➡️ **클라이언트**: 최종 IP 주소 응답 (Recursive Query 완료)

---

# 문제

1. 인터넷에서 주로 사용하는 모델과 그 이유.
    1. OSI 모델보다 먼저 개발되어 인터넷의 표준으로 자리 잡았으며, 이론보다는 실제 구현에 초점
2. TCP/IP 응용 계층 통합의 장단점
    1. 장점은 단순성과 효율성. OSI 모델처럼 세션, 표현, 응용 계층을 엄격히 구분하지 않아 프로토콜 개발이 더 간단하고, 실제 데이터 처리 시 계층 간 이동에 따른 오버헤드가 줄어들어 더 효율적.
    2. 단점은 모듈화의 부재. 역할 구분이 명확하지 않아 하나의 프로토콜(예: HTTP)이 세션 관리, 데이터 표현, 응용 로직 등 여러 역할을 동시에 수행. 이는 OSI 모델의 설계 철학인 '역할의 명확한 분리'와는 거리가 멀다.
3. 웹 브라우저에 주소를 입력했는데 페이지가 뜨지 않을 때, 네트워크 계층별로 어떤 문제?
    1. **네트워크 접근 계층:** 물리적인 연결 문제. 랜선이 뽑혔거나 Wi-Fi가 꺼져 있는지, 공유기 전원은 켜져 있는지 확인합니다.
    2. **인터넷 계층:** IP 주소 및 라우팅 문제. `ping 8.8.8.8` 같은 외부 IP로 테스트하여 인터넷 연결 자체는 되는지 확인합니다. PC에 IP 주소가 제대로 할당되었는지 확인합니다.
    3. **전송 계층:** 포트 문제. 방화벽이 HTTP/HTTPS 통신에 사용되는 80/443번 포트를 차단하고 있는지 확인합니다.
    4. **응용 계층:** DNS 또는 애플리케이션 문제. `nslookup www.google.com` 명령어로 도메인 이름이 IP 주소로 정상적으로 변환되는지 확인합니다. DNS 서버에 문제가 있을 수 있습니다. 또는 웹 브라우저 자체의 캐시나 설정 문제일 수도 있습니다.
4. TCP 흐름 제어의 동작 방식
    1. 먼저 데이터를 받는 **수신 측**이 현재 자신이 처리할 수 있는 데이터의 양(버퍼 크기)을 TCP 헤더의 **Window Size** 필드에 담아 **송신 측**에 알립니다.
    2. 송신 측은 수신 측이 보내온 **Window Size** 값을 확인하고, 그 크기를 초과하지 않는 범위 내에서만 데이터를 전송합니다.
    3. 수신 측이 데이터를 처리하면 Window Size가 늘어나고, 이 정보를 다시 송신 측에 알려주어 전송량을 조절하게 됩니다.
5. 왜 연결은 3-way, 해제는 4-way?
    1. TCP의 **'전이중(Full-Duplex) 통신'** 특성
    2. **TCP 3-Way Handshake (연결)**
        1. **이유:** 양쪽(클라이언트 & 서버)이 **동시에 통신할 준비가 되었는지 서로 확인**하고, **초기 시퀀스 번호(ISN)를 동기화**하는 최소한의 과정
        2. **핵심:** 양쪽 모두 `SYN`을 보내고 `ACK`를 받는 것을 **서로 확인**해야 전이중(Full-Duplex) 통신의 양방향 채널이 확립됨. (SYN - SYN/ACK - ACK)
    3. **TCP 4-Way Handshake (해제)**
        1. **이유:** TCP는 **전이중(Full-Duplex) 통신**이기 때문에, **각 방향의 데이터 흐름(송신)을 독립적으로 종료**해야 함.
        2. **핵심:** 한쪽에서 `FIN`을 보내는 것은 *자신이 더 이상 보낼 데이터가 없다*는 의미일 뿐, 상대방은 아직 보낼 데이터가 남아 있을 수 있음. 따라서 각자의 송신 채널 종료를 `FIN`으로 알리고, 상대방은 이를 `ACK`한 후 자신의 송신 채널이 종료될 때 다시 `FIN`을 보내는 독립적인 과정이 필요. (FIN - ACK - FIN - ACK)
6. API Gateway란?
    1. **정의:** 클라이언트와 백엔드 마이크로서비스 간의 **중앙 진입점(Single Entry Point)** 역할을 하는 서버
    2. **역할:**
        1. 클라이언트 요청을 받아 적절한 마이크로서비스로 **라우팅** (길 안내).
        2. **인증/인가, 로깅, 속도 제한** 등 여러 서비스에 공통적으로 필요한 기능들을 처리 (공통 기능 처리).
        3. 여러 서비스의 응답을 모아 하나의 응답으로 클라이언트에 전달 (응답 조합).
    3. **필요성:** 마이크로서비스 아키텍처에서 클라이언트의 복잡성을 줄이고, 공통 기능을 중앙 집중화하여 관리 효율성과 시스템 유연성을 높임.
    4. **특징:** 아키텍처 **패턴**이자, 그 패턴을 구현한 **컴포넌트/제품**을 지칭.