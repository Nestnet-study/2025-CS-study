# 트랜잭션과 프로시저

## 1. 트랜잭션 (Transaction)

트랜잭션은 하나의 논리적인 작업을 수행하기 위한 쿼리의 집합으로 전부 성공적으로 실행되거나 하나라도 실패하면 전부 실행되지 않은 상태로 돌아가야 한다는 원칙을 따른다.

### 트랜잭션의 4대 원칙: ACID

1. **원자성 (Atomicity)**
   - 모든 작업은 commit 되거나 전부 실패되어 rollback 해야 한다.
2. **일관성 (Consistency)**
   - 트랜잭션이 완료된 후 데이터베이스는 일관성 있는 상태를 유지해야 한다.
   - 예를 들어, 계좌 이체 전후의 총잔액은 변함이 없어야 한다는 등의 데이터베이스 제약 조건이나 규칙을 위반해서는 안 된다.
3. **고립성/격리성 (Isolation)**
   - 하나의 트랜잭션이 실행되는 동안에는 다른 트랜잭션이 중간 과정에 끼어들어 간섭할 수 없다.
   - 각 트랜잭션은 마치 시스템에 자기 혼자만 실행되는 것처럼 보여야 하며, 이를 통해 여러 트랜잭션이 동시에 실행되더라도 데이터가 꼬이는 것을 방지한다.
4. **지속성 (Durability)**
   - Commit된 트랜잭션의 결과는 시스템에 장애가 발생하더라도 영구적으로 저장되어야 한다.

---

## 2. 트랜잭션의 상태 변화

### **Active (활동 상태)**

- 트랜잭션이 실행 중인 상태이다.
- 에러가 발생하거나 특정 조건에 의해 Failed 상태로 전환될 수 있다.
- 모든 연산이 성공적으로 실행되면 Partially Commited 상태로 넘어간다.

### **Partially Committed (부분 완료 상태)**

- 트랜잭션의 마지막 연산까지 성공적으로 실행된 직후의 상태이다.
- 모든 연산은 끝났지만, 변경된 내용이 아직 데이터베이스에 영구적으로 저장되지는 않은 상태이다.
- 이 시점에서 어떤 장애가 발생해 데이터베이스에 변경사항을 반영하지 못하면 Failed 상태로 갈 수 있다.
- 변경 내용을 데이터베이스에 반영하는 COMMIT 이 완료되면 Commited 상태로 전환된다.

### **Committed (완료 상태)**

- 트랜잭션이 성공적으로 종료되었음을 의미하는 상태이다.
- `COMMIT` 연산이 실행된 후, 트랜잭션의 모든 변경 내용이 데이터베이스에 영구적으로 반영된다.
- 일단 Committed 상태가 되면, 시스템에 장애가 발생하더라도 해당 변경 내용은 보존된다.

### **Failed (실패 상태)**

- 트랜잭션 실행 중 오류가 발생하여 더 이상 정상적인 진행이 불가능한 상태이다.
- 하드웨어 고장, 데이터 불일치, 논리적 오류 등 다양한 원인으로 이 상태가 될 수 있다.
- 일단 Failed 상태가 되면, 트랜잭션은 복구(Rollback) 절차를 시작해야 한다.

### **Aborted (철회 상태)**

- 트랜잭션이 비정상적으로 종료되어 Rollback을 수행한 후의 상태이다.
- 롤백은 트랜잭션이 시작되기 이전의 상태로 데이터베이스를 되돌리는 작업을 의미한다. 즉, 트랜잭션의 모든 변경 사항을 취소한다.
- 이것은 트랜잭션의 최종 실패 상태이다.

---

## 3. 저장 프로시저 (Stored Procedure)

프로시저는 데이터베이스에 저장된 미리 컴파일된 SQL의 집합이다. 자주 사용되거나 복잡한 일련의 SSQL 쿼리 및 로직을 마치 하나의 함수처럼 만들어 데이터베이스 서버에 저장해두는 것이다.

```sql
CREATE PROCEDURE usp_RegisterNewUser @userId VARCHAR(50), @password VARCHAR(100), @email VARCHAR(100)
AS
BEGIN -- 1. 회원 테이블에 정보 삽입 INSERT INTO Users (userId, password, email, joinDate) VALUES (@userId, @password, @email, GETDATE()); -- 2. 환영 쿠폰 발급 INSERT INTO Coupons (userId, couponType, expiryDate) VALUES (@userId, 'WELCOME_10', DATEADD(day, 30, GETDATE())); -- 3. 가입 로그 기록 INSERT INTO Logs (logMessage) VALUES (CONCAT('
```

이제 개발자는 이 모든 SQL을 알 필요 없이, 간단하게 `EXEC usp_RegisterNewUser 'newUser', 'pwd123', 'new@example.com'` 처럼 호출만 하면 된다.

### 저장 프로시저의 장점

- **성능 향상**: 최초 실행 시 한 번만 컴파일되고, 이후에는 캐시된 실행 계획을 재사용하므로 반복적인 쿼리 실행보다 빠르다.
- **네트워크 부하 감소**: 클라이언트가 서버로 긴 SQL문을 보내는 대신, 짧은 프로시저 호출 구문만 보내므로 네트워크 트래픽이 줄어든다.
- **재사용성 및 유지보수 용이**: 공통적으로 사용되는 로직을 프로시저로 만들어두면 여러 애플리케이션에서 재사용할 수 있다.
- **보안 강화**: 사용자에게 테이블에 대한 직접적인 접근 권한을 주는 대신, 프로시저를 실행할 수 있는 권한만 부여할 수 있다.

### 저장 프로시저의 단점

- **데이터베이스 의존성 증가**: 프로시저는 특정 RDBMS의 SQL 문법(PL/SQL, T-SQL 등)에 종속적이다.
- **어려운 디버깅 및 버전 관리**: 애플리케이션 코드에 비해 디버깅이 까다로우며, Git과 같은 형상 관리 시스템으로 버전을 관리하기가 번거롭다.
- **DB 서버 부하 증가**: 복잡한 로직이 DB 서버에서 직접 실행되므로, 애플리케이션 서버가 아닌 DB 서버의 CPU와 메모리 사용량이 늘어날 수 있다.
