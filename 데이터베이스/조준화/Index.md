# 인덱스

## 1. 인덱스의 자료구조

**B-Tree**

1. 루트 노드에서 시작하여 찾으려는 값과 노드 키값 비교
2. 노드의 키보다 작으면 왼쪽 자식으로, 크면 오른쪽으로
3. 이를 반복하여 데이터를 담고 있는 노드까지 도달

- 데이터는 Key와 함께 저장되며 모든 노드에 데이터 포인터가 존재할 수 있음.

**B+Tree**

- B-tree와 비슷하게 동작하며 최종 데이터를 찾기 위해서는 리프 노드까지 도달해야 함
- B+Tree는 오직 리프 노드에만 데이터 포인터 저장 → 하나의 노드에 더 많은 Key 저장 가능 → 트리의 높이 더 낮게 유지 → Disk IO를 줄임
- 모든 리프 노드는 연결 리스트로 연결됨. → 범위 검색에 유리

---

## 2. 인덱스 사용 이유

데이터 검색의 속도 향상이다. 인덱스가 없다면 Full table scan을 해야 한다. index는 특정한 컨디션에 맞는 레코드를 O(1)로 찾을 수 있다.

1. 고속 검색 : WHERE 절, JOIN 조건에 사용되는 컬럼에 인덱스를 걸면 검색 속도가 매우 빨라짐
2. 정렬 부하 감소 : 인덱스는 이미 Key 값을 기준으로 정렬되어 있음
3. 데이터 무결성 강화 : PK나 UNIQUE 제약 조건은 인덱스를 통해 구현됨.

**단점**

1. 쓰기 성능 저하 : 테이블 + 인덱스 트리까지 변경되므로 오버헤드 증가
2. 추가 저장 공간 필요

**인덱스 설계 시 고려사항**

- 읽기 성능은 최대화하면서 CUD 성능 저하는 최소화 하는 것이 목표

1. Cardinality가 높은 컬럼을 우선 고려하기
   - 카디널리티 : 고유한 값의 개수
   - 이메일처럼 카디널리티가 높은 컬럼은 효율이 매우 좋음
2. WHERE 절에서 자주 사용되는 컬럼에 생성하기
3. 복합 인덱스의 컬럼 순서
   - 자주 사용되고 동등 조인 조건으로 사용되는 컬럼을 앞 순서에 두는 것이 좋음
4. FK 컬럼에는 인덱스 생성 → JOIN 성능 향상
5. 쓰기 작업이 빈번한 테이블은 인덱스 X

---

## 3. Index의 종류

### Primary Index

- 테이블의 PK에 대해 생성되는 인덱스
- 정렬되어 있기에 추측이 가능하다. 즉, sparse 하다. 각 block의 첫 번째 레코드만 표시해도 된다는 뜻이다.
- 정렬되어있으므로 log N 번의 disk IO가 발생한다.
- 테이블 내의 모든 행을 고유하게 식별한다.
- 특정 행에 가장 빠르게 접근할 수 있다.
  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8bd42bc8-7ea0-4ea0-944e-dcd48d593f77/6554f3b0-bc4a-4efa-9db7-fd0c85ddb462/image.png)

### Clustering Index

- non-key 필드에 대해 index를 만드는 것이다. 두 개의 필드로 구현되며 sparse 하다.
- non key 필드이므로 각 값이 고유하지 않다. 이를 정렬하여 1111 222 333 이런식으로 저장하게 되고, 1, 2, 3, ..이 처음 나타나는 곳, 다음 블락이 시작되는 곳만 포인팅하면 된다.
  ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/8bd42bc8-7ea0-4ea0-944e-dcd48d593f77/d968c55e-f1e3-4a91-8824-dade8065e0c0/image.png)

### RDBMS에서 클러스터링 인덱스

주요 RDBMS에서의 클러스터링 인덱스는 테이블 데이터의 물리적인 저장 순서를 결정하는 PK 기반의 인덱스이다. 중요한 점은 클러스터링 인덱스는 별도의 index 파일이 아닌, 테이블 데이터 그 자체를 B+ 트리 구조로 정렬하여 저장하는 방식인 것이다.

- 인덱스 자체에 모든 데이터가 포함되어 있다.
- 테이블당 오직 하나만 존재할 수 있다.
- PK를 클러스터링 index로 구현하는 것이라 생각하면 된다.

### Secondary Index

Clustering Index를 제외한 모든 인덱스를 의미한다.

- 보조 인덱스는 실제 데이터의 물리적 주소 대신 인덱스 키 값과 해당 데이터의 PK 값을 가지고 있다. 따라서 다음 단계로 검색을 하게 된다.
  1. 보조 인덱스에서 사용자가 검색한 값으로 데이터의 PK 검색
  2. 그 PK를 가지고 클러스터링 인덱스를 다시 탐색하여 최종 데이터 행을 가져옴
- 테이블 당 여러 개 생성할 수 있다.
- 보조 인덱스에서 PK를 검색하는 과정은 B+tree에서 검색이기에 log N이다. 그 후 클러스터링 index를 다시 탐색하는 것도 B+tree이기에 log N이다.
- 다만 보조 인덱스 자체는 dense하다. 보조 인덱스 키를 기준으로 본 실제 데이터의 물리적 순서는 정렬되어 있지않기 때문이다.

### 복합 Index

복합 인덱스는 모든 컬럼을 하나의 긴 데이터처럼 묶어서 사전식 정렬(Lexicographical Order) 원칙에 따라 정렬한다. `INDEX(category, brand, release_date)` 의 경우, 정렬 순서는 다음과 같다.

1. `category`를 기준으로 먼저 정렬
2. `category`가 같다면, 그 안에서 `brand`를 기준으로 정렬
3. `category`와 `brand`가 모두 같다면, 그 안에서 `release_date`를 기준으로 정렬

---

## 4. 커버링 Index

Covering Index는 보조 인덱스를 활용하는 하나의 방식으로 쿼리에 필요한 모든 데이터를 담고 있는 인덱스이다.

일반 인덱스는 실제 데이터를 담고 있는 B+Tree의 위치를 포인팅한다. 우리는 이 포인터를 바탕으로 B+Tree로 가서 순회를 해야 한다.

커버링 인덱스는 B+ Tree가 함께 저장되어 index 방문과 동시에 데이터에 접근할 수 있다.

### 커버링 인덱스는 왜 그렇게 빠른가?

커버링 인덱스의 성능 향상 원리는 데이터 접근 방식이다. 예시로 보자.

예시는 `users` 테이블에서 특정 이름을 가진 사용자의 이메일을 조회하는 것이다.

- SQL : `SELECT email FROM users WHERE name = '홍길동';`

1. Case 1 : `name` 컬럼에만 인덱스가 있는 경우 (커버링 인덱스 X)
   1. 보조 인덱스 탐색: `name`을 위한 보조 인덱스에서 `홍길동` 검색 → 해당 데이터가 저장된 곳을 가리키는 PK 값을 얻음
   2. 클러스터링 인덱스 접근 : 획득한 PK를 가지고 실제 데이터가 저장된 클러스터링 인덱스로 다시 접근 → 최종 데이터 획득
   - 인덱스를 한 번 탐색하고, 테이블을 다시 한 번 탐색하여 disk IO를 추가로 유발함
2. Case 2: `(name, email)` 복합 인덱스가 있는 경우 (커버링 인덱스 O)
   1. 복합 인덱스 탐색 → 최종 데이터 바로 획득
      - 복합 인덱스는 `name` 값과 함께 `email` 값도 저장하고 있다. 따라서 '홍길동'을 찾는 즉시, 그 옆에 있는 `email` 값을 바로 읽어서 쿼리를 종료할 수 있다.
   - 인덱스 탐색 한 번의 작업으로 모든 것이 끝나므로 매우 빠르다.

**장점**

- 압도적인 쿼리 성능 향상
- 데이터베이스 부하 감소:

**단점**

- **더 큰 인덱스 크기**
- **쓰기 성능 저하**: `INSERT`, `UPDATE`, `DELETE` 작업 시, 테이블 데이터뿐만 아니라 더 커진 인덱스 트리도 함께 변경해야 한다.

### 설계 시 고려사항

커버링 인덱스는 강력하지만 모든 곳에 사용할 수는 없으므로, 전략적으로 설계해야 한다.

1. 자주 실행되는 조회 쿼리를 타겟으로 한다.
2. SELECT 절에 포함된 컬럼을 index에 포함시킨다. WHERE 절 조건만 포함시키면 안된다.
3. 읽기 비율이 압도적으로 많은 테이블에 사용한다.
4. SELECT \*에 맞춰 무분별하게 컬럼을 추가하는 것은 사실상 테이블을 하나 더 복제하는 것과 같으며 전혀 사용할 이유가 없다.

### 복합 인덱스 컬럼 순서 결정 원칙

1. 등호(=) 조건 & 선택도(Cardinality)가 높은 컬럼을 가장 앞으로
   - = 또는 IN 조건으로 사용되는 컬럼이 첫 번째 필터 역할을 하여 조회할 데이터 범위를 줄인다.
   - 여러 컬럼이 = 조건으로 사용된다면 선택도가 높은 컬럼을 앞에 두는 것이 좋다.
     - 선택도가 높다 = 고유한 값의 종류가 많다
2. 범위(Range) 조건에 사용되는 컬럼은 뒤로
   - 범위 조건에 사용되는 컬럼은 등호 조건 컬럼보다 뒤에 위치해야 한다.
     - 인덱스는 범위 검색이 시작되는 컬럼까지만 효율적으로 Seek 하고, 그 이후부터는 Scan 하기에 필터링 역할이 아니다.
   - 예로 `WHERE a=10 AND b>20` 을 생각해보자.
   - `INDEX(b, a)` : b가 20보다 큰 모든 데이터를 스캔하면서 a가 10인지 계속 확인해야 한다.
3. 정렬(ORDER BY / GROUP BY)에 사용되는 컬럼 고려
   - ORDER BY, GROUP BY에 자주 사용되는 컬럼은 `WHERE` 절의 조건과 `ORDER BY` 절의 순서가 인덱스 컬럼 순서와 일치할 때, 데이터베이스는 별도의 정렬 과정(filesort) 없이 인덱스에 정렬된 순서 그대로 데이터를 읽어오므로 매우 빠르다.
   - 예시 : `WHERE category = '전자제품' ORDER BY price ASC`
     - `INDEX(category, price)`: `category`로 범위를 좁히고, 이미 `price` 순으로 정렬된 인덱스를 그대로 읽어오기만 하면 되므로 정렬 작업이 ㅇ벗다.

---

## 5. NoSQL의 index

1. **데이터 모델 의존성**: RDBMS는 정규화된 테이블 구조를 기반으로 B-Tree 인덱스를 사용한다. 반면 NoSQL은 Document, Key-Value 등 다양한 모델이 있으며 모델에 최적화된 인덱싱 전략을 사용한다.
2. **읽기 패턴 최적화**: RDBMS는 일단 정규화해두고 어떤 쿼리든 유연하게 대응할 수 있다면 NoSQL은 특정 데이터 읽기 패턴을 미리 예측하고, 그 패턴에 맞춰 데이터 모델을 설계한다.
3. **쓰기 성능과의 트레이드오프**: NoSQL은 수평적 확장을 도모하기에 인덱스가 많아질수록 쓰기 성능 저하가 RDBMS 보다 더욱 심하게 체감된다.

### 문서 데이터베이스 (Document Databases) Ex. MongoDB

JSON 형태의 문서 내의 특정 필드 값을 기준으로 인덱스를 생성한다. RDBMS와 가장 유사하다.

- **단일 필드 인덱스 (Single Field Index)**: 문서 내의 특정 필드 하나에 인덱스를 거는 방식으로, RDBMS의 단일 컬럼 인덱스와 거의 동일하다.
- **복합 인덱스 (Compound Index)**: 여러 필드를 조합하여 인덱스를 만듭니다. RDBMS 복합 인덱스와 마찬가지로 필드의 순서가 매우 중요하다.
- **다중 키 인덱스 (Multikey Index)**: 문서 모델의 가장 큰 특징 중 하나이다. 필드 값이 배열(Array)일 경우, 배열의 각 요소에 대해 인덱스를 생성한다. 예를 들어 `tags: ["DB", "NoSQL", "Index"]` 라는 필드가 있다면, "DB", "NoSQL", "Index" 각각의 값으로 해당 문서를 찾아갈 수 있다. 반면 RDBMS에서는 이를 위해 별도의 테이블로 정규화해야 한다.
- **텍스트 인덱스 (Text Index)**: 문자열 내용에 대한 전문(Full-text) 검색을 지원한다.

### 키-값 데이터베이스 (Key-Value Stores) Ex. Redis, Amazon DynamoDB

모든 데이터는 고유한 Key와 그에 해당하는 Value로 저장된다.

- **기본 인덱스 (Primary Index)**: Key 자체가 Index이다. Key를 통한 데이터 접근은 O(1)이다.
- **보조 인덱스 (Secondary Index)**: Key가 아닌 Value 내부의 특정 값으로 데이터를 검색하고 싶을 때 사용한다. 유저 ID를 키로, 유저 정보를 Value로 저장할 때 Set이나 Hash를 구현하여 나이를 점수로 하는 Set을 만들면 나이순 정렬 및 검색을 구현할 수 있다.
