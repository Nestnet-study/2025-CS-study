# 트랜잭션 간의 동시성 제어

## 1. 스케줄의 종류

스케줄이란 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션에 속한 연산들의 실행 순서를 의미한다. DBMS는 스케줄을 관리하여 동시성과 일관성을 모두 보장하려 한다.

### **Serial Schedule (직렬 스케줄)**

- 여러 트랜잭션들을 순차적으로, 하나씩 실행하는 방식이다. 즉, 하나의 트랜잭션이 완전히 끝난 후에야 다음 트랜잭션이 시작된다.
- **특징**
  - **일관성 보장**: 트랜잭션들이 서로 간섭하지 않으므로 데이터베이스의 일관성(Consistency)이 항상 보장된다.
  - **낮은 성능**: 동시에 여러 요청을 처리할 수 없어 CPU나 디스크 같은 자원을 효율적으로 사용하지 못한다. 따라서 실제로는 잘 사용되지 않는다.
- T1 실행 → T1 완료 → T2 실행 → T2 완료와 같은 스케줄이다.

### **Serializable Schedule (직렬 가능 스케줄)**

- 여러 트랜잭션들을 동시에 실행하지만, 그 실행 결과가 어떤 Serial 스케줄의 실행 결과와 동일한 스케줄이다.
- **특징**
  - **동시성 + 일관성**: 동시 실행을 통해 시스템의 성능과 처리량을 높이면서도, 결과적으로는 순차 실행과 동일한 결과를 보장하여 데이터베이스의 일관성을 유지한다.
  - 대부분의 DBMS가 추구하는 가장 이상적인 스케줄이다.
  - 어떤 스케줄이 직렬 가능한지 판별하기 위해 '충돌 직렬 가능성(Conflict Serializability)' 등의 이론을 사용한다.

### **Recoverable Schedule (회복 가능 스케줄)**

- 트랜잭션 실행 중 장애가 발생했을 때 데이터베이스를 일관된 상태로 복구할 수 있는 스케줄이다.
- 만약 트랜잭션 T2가 트랜잭션 T1이 변경한 데이터를 읽는다면, **T1이 반드시 T2보다 먼저 Commit 되어야 한다**는 규칙을 따른다.
- **예시**
  - **회복 불가능한 경우 (Bad Case)**
    1. T1: A의 값을 10에서 20으로 변경 (`Write(A)`)
    2. T2: T1이 변경한 A의 값(20)을 읽음 (`Read(A)`)
    3. T2: 자신의 작업을 마치고 **`Commit`**
    4. T1: 오류가 발생하여 **`Abort`** (A 값을 원래대로 10으로 롤백)
    - T2는 이미 존재하지 않는 값, 20을 기반으로 작업하고 Commit 해버려 데이터베이스에 영구적으로 저장되버렸다. 하지만 T1은 롤백되어 A의 값이 10이 되어버렸고 일관성을 해치는 상태에 빠진다.
  - **회복 가능한 경우 (Good Case)**
    1. T1: A의 값을 10에서 20으로 변경 (`Write(A)`)
    2. T2: T1이 변경한 A의 값(20)을 읽음 (`Read(A)`)
    3. T1: 자신의 작업을 마치고 **`Commit`**
    4. T2: 이제 T1이 확정되었으므로, 자신도 **`Commit`** 가능
    - 3번 과정에서 T1이 Abort 해도 T2는 아직 Commit 하지 않았으므로 함께 Abort 하여 일관성을 지킬 수 있다.

요약하자면 현대 DBMS는 회복 가능하면서 직렬 가능한 스케줄을 지향한다.

---

## 2. 락(Lock)

직렬 가능 스케줄을 보장하기 위한 대표적인 방법이 락이다.

- 락(Lock, 잠금)은 여러 트랜잭션이 **동시에 동일한 데이터에 접근하는 것을 제어하기 위한 메커니즘이다.**
- 어떤 트랜잭션이 특정 데이터에 대해 락을 획득하면, 락의 종류와 다른 트랜잭션의 요청에 따라 접근이 허용되거나 대기하게 된다. 이를 통해 데이터의 무결성을 지킬 수 있다.

### 공유 락과 배타 락

1. **공유 락 (Shared Lock, S-Lock)**
   - 데이터 Read를 위한 락이다.
   - 공유 락이 걸린 데이터는 다른 트랜잭션도 공유 락을 획득하고 읽을 수 있다.
   - 하지만 누구라도 배타 락을 획득하여 수정하려 하면, 모든 공유 락이 해제될 때까지 대기해야 한다.
2. **배타 락 (Exclusive Lock, X-Lock)**
   - 데이터 변경을 위한 락이다.
   - 배타 락이 걸린 데이터는 다른 어떤 트랜잭션도 공유 락과 배타 락을 모두 획득할 수 없다. 오직 배타락을 획득한 트랜잭션만이 데이터를 변경할 수 있으며, 이 트랜잭션이 락을 해제할 때까지 다른 모든 트랜잭션은 대기해야 한다.

### 비관적 락 (Pessimistic Lock)

데이터 충돌 발생을 가정하고 우선 락을 거는 방식이다. 동작 방식은 다음과 같다.

1. 트랜잭션이 데이터를 읽거나 수정하기 전에 먼저 해당 데이터에 락을 요청하여 획득한다.
2. 락을 획득한 트랜잭션만이 해당 데이터에 대한 작업을 수행할 수 있다.
3. 다른 트랜잭션은 락이 해제될 때까지 Block 된다.
4. 작업이 끝나면 락이 해제된다.

높은 데이터 정합성을 보장할 수 있고 충돌 처리 로직을 복잡하게 구현할 필요가 없다는 장점을 가진다.

하지만 동시성이 낮고 Deadlock이 발생할 가능성이 존재한다.

데이터 충돌이 빈번하게 일어날 것으로 예상되거나 은행 등의 데이터 정합성이 매우 중요한 경우 사용한다.

### 낙관적 락 (Optimistic Lock)

데이터 충돌이 거의 발생하지 않을 것이라 가정하고 락 없이 작업을 진행하는 방식이다.

- 보통 락을 사용하지 않고 Version 관리 기능을 이용하는 것이 일반적이다.

**동작 방식**

1. 트랜잭션이 데이터를 읽을 때, 데이터와 함께 버전 정보(e.g., `version` 컬럼, 타임스탬프)를 함께 읽어온다.
2. 데이터베이스에 락을 걸지 않은 채로, 애플리케이션 단에서 자유롭게 작업을 수행한다.
3. 작업을 마치고 데이터를 수정(Update)하려고 할 때, 자신이 처음에 읽었던 버전 정보와 현재 데이터베이스의 버전 정보가 일치하는지 확인한다.
   - 버전이 일치하는 경우 : 아무도 데이터를 수정하지 않았으므로 데이터 수정 후 버전 정보를 증가시키고 커밋한다.
   - 버전이 불일치하는 경우 : 다른 트랜잭션이 데이터를 수정했다는 의미이다. 즉, 충돌이 발생한 것이고 현재 트랜잭션을 롤백한다.

높은 동시성을 가지고 Deadlock이 없다.

하지만 충돌이 발생했을 때 로직을 구현해야하고 잦은 충돌 시 계속해서 롤백과 재시도가 일어나는 Starvation 현상이 발생할 수 있다.

읽기 작업이 쓰기 작업보다 훨씬 많은 환경. 게시글 수정 등의 데이터 충돌이 거의 발생하지 않을 것으로 예상되는 경우 사용한다.

---

## 3. MVCC (Multi-Version Concurrency Control, 다중 버전 동시성 제어)

MVCC는 락의 단점을 보완하기 위해 등장한 개념이다. 데이터를 수정할 때마다 기존 데이터를 덮어쓰는 것 대신, 새로운 버전의 데이터를 만드는 방식이다. 동작 방식은 다음과 같다.

1. 어떤 트랜잭션이 데이터를 수정하면, DBMS는 기존 데이터를 지우지 않고 **새로운 버전의 데이터를 생성한다**. (보통 Undo 로그나 별도의 공간에 이전 데이터를 저장)
2. 각 트랜잭션은 자신이 시작된 시점을 기준으로, 그 시점에 유효했던 버전의 데이터만 읽어온다. 이를 스냅샷이라 한다.
3. 따라서 데이터를 읽는 트랜잭션은 현재 다른 트랜잭션이 데이터를 수정하고 있더라도, 락 없이 자신의 스냅샷 버전을 읽을 수 있다.

MVCC는 읽기-쓰기 충돌을 방지할 수 있다. 즉, 읽기 작업과 쓰기 작업은 서로를 절대 기다릴 수 없어 동시성을 극대화할 수 있다.

하지만 MVCC는 트랜잭션에게 구 버전의 스냅샷을 제공할 수 있다. 낙관적 락을 생각하면 된다.

---

## 4. 트랜잭션 격리 수준 (Transaction Isolation Level)

데이터베이스의 일관성을 얼마나 강력하게 지킬 것인가를 설정하는 단계이다. 격리 수준이 높을수록 데이터 정합성은 완벽해지지만 락이 더 많이 걸리는 등 동시성은 떨어진다. SQL 표준에서는 이를 4가지 수준으로 정의한다.

| 격리 수준            | 발생 가능한 이상 현상                         | 설명                                                                       |
| -------------------- | --------------------------------------------- | -------------------------------------------------------------------------- |
| **Read Uncommitted** | Dirty Read, Non-Repeatable Read, Phantom Read | 커밋되지 않은 데이터도 읽을 수 있음. 정합성 문제가 심각해 거의 사용 안 함. |
| **Read Committed**   | Non-Repeatable Read, Phantom Read             | 커밋된 데이터만 읽음. 대부분의 DBMS 기본값.                                |
| **Repeatable Read**  | Phantom Read                                  | 한 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 값이 나옴.       |
| **Serializable**     | 없음                                          | 가장 엄격한 수준. 트랜잭션을 직렬로 실행하는 것과 같은 결과를 보장.        |

**이상 현상(Anomaly) 설명**

- **Dirty Read**: 트랜잭션 A가 수정한 데이터를 커밋하기도 전에, 트랜잭션 B가 그 데이터를 읽는 현상. (만약 A가 롤백하면 B는 '유령' 데이터를 읽은 셈이 됨)
- **Non-Repeatable Read**: 한 트랜잭션 내에서 같은 행(Row)을 두 번 읽었는데 그 사이에 다른 트랜잭션이 값을 수정/삭제하여 결과가 다르게 나오는 현상. 즉, 한 트랜잭션 안에서 같은 데이터를 두 번 읽었는데 결과가 다르게 나오는 문제이다.
- **Phantom Read**: 한 트랜잭션 내에서 같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에는 없던 '유령' 같은 행(Row)이 두 번째 쿼리에서 나타나는 현상. (다른 트랜잭션이 새로운 행을 INSERT 함) 즉, 한 트랜잭션 안에서 같은 범위로 두 번 쿼리했는데 결과물의 양이 달라지는 문제이다.

---
