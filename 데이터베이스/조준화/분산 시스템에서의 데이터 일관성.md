# 분산 시스템에서의 데이터 일관성

## 1. 투페이즈 커밋

투페이즈 커밋(2PC)는 분산된 시스템에 걸친 하나의 트랜잭션의 원자성을 보장하는 분산 원자성 커밋 프로토콜이다.

CAP 이론에서 일반적인 트랜잭션은 C를 선택하여 강한 정합성을 보장하는게 일반적이다. 하지만, 분산 시스템은 보통 AP를 택한다. 따라서 네트워크 문제가 생겨 노드 간 통신이 끊어지는 분할 상황이 발생하더라도 시스템은 멈추지 않고 가용성을 유지해야 한다. 하지만 그렇다고 해서, 데이터 정합성을 포기해서는 안된다.

일반 커밋은 네트워크 분할이 발생했을 때 데이터 정합성이 반드시 깨지게 된다. 일반적인 커밋은 하나의 데이터베이스의 작업들을 원자적으로 묶는 방식이다. 따라서 중간에 장애가 발생하면 부분적인 성공이 발생하여 데이터 정합성을 깨지게 둘 수 밖에 없다.

투페이즈 커밋은 이를 논리적인 원자성으로 해결하였다.

투페이즈 커밋에는 두 종류의 참여자가 존재한다.

- **조정자 (Coordinator)**: 전체 분산 트랜잭션을 관리하고 모든 참여자에게 실행 여부를 묻고 최종 결정을 내린다.
- **참여자 (Participant / Cohort)**: 트랜잭션에 참여하는 개별 시스템들이다.

### 동작 방식

**Phase 1: 준비 단계 (Prepare Phase)**

- 조정자가 모든 참여자에게 커밋 준비를 요청한다.

1. 조정자가 모든 참여자에게 `PREPARE` 메시지를 보낸다.
2. `PREPARE` 메시지를 받은 각 참여자는 자신의 작업을 수행하고, 이 작업을 언제든지 커밋할 수도, 롤백할 수도 있는 '준비된' 상태로 만든다.
   - 예를 들어, 데이터베이스는 변경 내용을 디스크의 트랜잭션 로그에 안전하게 기록하고, 관련된 리소스에 락을 거는 등이다.
3. 준비에 성공했다면, 참여자는 조정자에게 `YES` 를 응답한다. 이 응답을 보낸 참여자는 어떤 상황에서도 커밋을 보장할 수 있어야 한다.
4. 만약 준비 과정에서 실패했다면 `NO` 라고 응답하고 즉시 자신의 작업을 롤백한다.

**Phase 2: 커밋 단계 (Commit Phase)**

- 조정자가 모든 참여자의 응답을 보고 최종 결정을 내린 뒤 전파하는 과정이다.
- Case 1: 모두 `YES`라고 응답한 경우 (성공)
  1. 조정자는 모든 참여자가 준비되었음을 확인하고, 트랜잭션의 최종 결정을 `COMMIT` 으로 내린다.
  2. 조정자는 모든 참여자에게 `COMMIT` 메시지를 전송한다.
  3. `COMMIT` 메시지를 받은 참여자는 '준비된' 상태의 작업을 영구적으로 데이터베이스에 반영(커밋)하고, 잡고 있던 락을 해제한다.
  4. 작업을 완료한 참여자는 조정자에게 `ACK`(확인) 메시지를 보낸다.
  5. 조정자가 모든 ACK를 받으면, 전체 분산 트랜잭션이 성공적으로 완료된다.
- Case 2: 단 한 명이라도 `NO`라고 응답하거나 타임아웃된 경우 (실패)
  1. 조정자는 트랜잭션의 최종 결정을 `ABORT`로 내린다.
  2. 조정자는 모든 참여자에게 `ABORT` (또는 `ROLLBACK`) 메시지를 전송한다.
  3. `ABORT` 메시지를 받은 참여자(`YES`라고 응답했던 참여자 포함)는 '준비된' 상태의 작업을 모두 취소(롤백)하고, 잡고 있던 락을 해제한다.
  4. 작업을 롤백한 참여자는 조정자에게 `ACK` 메시지를 보낸다.
  5. 전체 분산 트랜잭션이 안전하게 실패 처리된다.

### 투페이즈 커밋의 치명적인 단점

투페이즈 커밋은 원자성을 강력하게 보장하지만, 몇 가지 심각한 단점이 있어 현대적인 마이크로서비스 아키텍처에서는 사용을 기피하는 추세이다.

1. **블로킹 문제 (Blocking Problem)**: 조정자가 1단계를 마친 후 2단계에서 최종 메시지를 보내기 전에 다운된다면?
   - `YES`라고 참여자들은 최종 결정을 받지 못했으므로 무한히 기다려야 한다.
   - 그 뿐 아니라, 락을 해제할 수 없기에 해당 리소스를 사용하려는 다른 모든 트랜잭션들까지 전부 대기 상태에 빠진다.
2. **단일 실패 지점 (Single Point of Failure, SPOF)**: 모든 결정을 조정자 혼자 내리므로, 조정자에 장애가 발생하면 전체 시스템이 멈춘다.
3. **성능 저하**: 여러 참여자와 여러 번의 네트워크 통신을 동기적으로 수행해야 하므로, 단일 시스템에서의 트랜잭션보다 훨씬 느리고 복잡하다.

---

## 2. 쓰리페이즈 커밋

2PC의 가장 큰 문제인 블로킹 문제를 해결하고자 단계를 하나 더 추가한 프로토콜이다. 조정자가 다운되더라도 참여자들이 무한히 기다리지 않고 스스로 결정을 내리 수 있게 한다.

**동작 방식**

1. CanCommit (준비 단계) : 조정자가 참여자에게 커밋이 가능한지 메시지를 보낸다.
2. PreCommit (예비 커밋 단계): 모든 참여자가 'YES'라고 답하면, 조정자는 곧 커밋할 예정이라는 `PreCommit` 메시지를 보낸다.
3. DoCommit (커밋 단계): 조정자가 최종 `COMMIT` 메시지를 보낸다.

PreCommit을 추가함으로써 조정자가 모든 참여자에게 메시지를 받았는지를 확인할 수 있다. 타임아웃으로 참여자들이 스스로 롤백을 할 수 있는 것이다.

PreCommit이 없을 때 타임아웃을 사용한다면 메시지가 도달한 특정 서비스는 커밋했는데, 메시지가 도달하지 못한 다른 서비스는 롤백하여 원자성을 깨뜨릴 수 있다. 그렇다고 참여자들끼리 복구 프로토콜을 사용할 수도 없다. 참여자들은 YES, NO를 받기도 전에 네트워크가 끊겼기에 서로가 Prepared 상태인 것만 인지하고, YES를 답했는지 NO를 답했는지 알 수 없다.

반면, 3PC에서는 준비 이후 바로 커밋이 아니기에, 2단계에서 오류가 발생하더라도 PreCommit을 보고 사용자들끼리 판단할 수 있다. 최종 결정이 커밋이 아니라면 PreCommit을 보내지도 않기 때문이다. 그렇다면 PreCommit 자체가 도달하지 않는다면? 아쉽지만 롤백해버리면 된다.

결론적으로 PreCommit 상태를 도입하므로써 최종 결정이 커밋인지 롤백인지를 모든 참여자에게 전파한다. 이를 통해 참여자들은 스스로 커밋하거나 롤백할 수 있는 기능이 생긴 것이다.

**장점**

- 조정자가 `PreCommit` 단계 이후에 다운되더라도, 참여자들은 타임아웃이 지나면 '모든 참여자가 PreCommit 상태에 도달했을 것'이라고 추측하고 자율적으로 커밋을 진행할 수 있다. 이로써 2PC의 블로킹 문제를 회피한다.

단점

- 프로토콜이 더 복잡해지고 통신 네트워크 비용이 증가한다.
- 네트워크 단절 문제까지 완벽하게 해결하지는 못했다.

---

## 3. 사가 패턴

- 긴 비즈니스 트랜잭션을 원자적으로 보장하는 대신, 최종적 일관성을 보장하는 방식이다.

**동작 방식**

- 하나의 거대한 분산 트랜잭션을 잘게 쪼개진 로컬 트랜잭션의 연속으로 취급한다. 각 로컬 트랜잭션이 성공하면 다음 단계를 호출한다. 만약 중간에 어느 단계가 실패하면, 이전 단계들이 수행했던 작업들을 모두 취소하는 보상 트랜잭션을 실행한다.
- 예시 (온라인 주문)
  1. 주문 서비스: 주문 생성 (성공) → 다음 단계 호출
  2. 결제 서비스: 결제 처리 (성공) → 다음 단계 호출
  3. 재고 서비스: 재고 차감 (실패!)
  4. 보상 트랜잭션 실행
     - 결제 서비스: 결제 취소
     - 주문 서비스: 주문 상태 '실패'로 변경

**장점**

- 느슨한 결합(Loose Coupling): 서비스 간 의존성이 낮다.
- 블로킹 없음

**단점**

- 복잡성: 모든 실패 시나리오에 대한 보상 트랜잭션을 개발자가 직접 구현해야 하므로 설계가 매우 복잡하다.
- 중간 상태 노출: 트랜잭션이 진행되는 중간에는 데이터 일관성이 깨진 상태(예: 결제는 됐지만 재고는 그대로인 상태)가 일시적으로 존재할 수 있다.

---

## 4. 합의 알고리즘 - Paxos, Raft

Paxos, Raft는 분산 시스템에서 여러 노드가 하나의 값에 대해 합의하는 방법에 집중한다.

- 여러 노드 중 하나를 리더(Leader)로 선출하고, 모든 데이터 변경(쓰기) 요청은 리더를 통해서만 이루어지도록 한다.
- 리더는 받은 요청을 다른 노드(팔로워)들에게 전파하고, 과반수 이상의 노드가 동의(복제 성공)하면 그 작업을 최종적으로 확정(커밋)하고 결과를 클라이언트에게 알려준다.
- 2PC처럼 모든 노드의 만장일치를 기다리지 않고 과반수(Majority)의 동의만 얻으면 진행할 수 있어 장애에 더 강건합니다.
- Raft는 Paxos의 개념을 더 이해하기 쉽게 만든 알고리즘으로, 현대의 많은 분산 시스템에서 사용된다.
