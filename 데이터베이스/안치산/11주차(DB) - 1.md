1주차
* **주요 주제:**
    * **RDBMS vs NoSQL:** 두 패러다임의 근본적인 차이점은 무엇인가? 어떤 상황에서 각각을 선택해야 하는가? (CAP 이론과 ACID 속성을 간략히 언급하며 비교)
 * **토론 포인트:**
    * "프로젝트 초기 단계에서 RDBMS를 선택했지만, 서비스가 성장하며 NoSQL로 마이그레이션하는 경우, 그 주된 이유는 무엇일까요?"
    * "정규화되지 않은 테이블 설계가 성능에 미치는 긍정적/부정적 영향은 무엇일까요?"

    * **트랜잭션(Transaction)과 ACID:**
        * 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability) 각 속성의 정확한 의미.
        * 트랜잭션의 상태 변화(Active, Partially Committed, Committed, Failed, Aborted).
* **토론 포인트:**
    * "의도적으로 비정규화(De-normalization)를 수행하는 경우는 언제이며, 이때 감수해야 할 트레이드오프는 무엇일까요?"
    * "트랜잭션의 네 가지 ACID 속성 중, 애플리케이션 로직과 가장 밀접하게 연관된 속성은 무엇이며 그 이유는 무엇이라고 생각하나요?"

---

## CAP 이론 핵심 정리

- **정의:** 분산 시스템은 **C**, **A**, **P** 세 가지 특성 중 **최대 두 개**만 가질 수 있다.   
    - **C**onsistency (일관성): 모든 노드가 **동일한 최신 데이터**를 가짐.       
    - **A**vailability (가용성): 어떤 요청에도 **항상 응답**함. (멈추지 않음)       
    - **P**artition Tolerance (분할 용인성): **네트워크 단절** 상황을 견뎌냄       
- **핵심 딜레마:** 네트워크 문제(**P**) 발생 시, **C**와 **A** 사이에서 선택해야 함.   
    - **CP (일관성 > 가용성):** 데이터 정확성을 위해 응답을 멈춤. (RDBMS, **MongoDB**)       
    - **AP (가용성 > 일관성):** 멈추지 않기 위해 잠시 다른 데이터를 보여줄 수 있음. (**Cassandra**, **DynamoDB**)       
- ~~**RDBMS의 위치:** 전통적으로 **CA**. 네트워크 분할을 고려하지 않은 단일 서버 환경.~~
## ACID 속성 핵심 정리

- **정의:** 트랜잭션의 **안정성**을 보장하는 네 가지 규칙. 주로 **RDBMS**의 특징.   
	- **A**tomicity (원자성): **All or Nothing**. 작업 전체가 성공하거나, 전체가 실패함. (예: 계좌 이체)   
	- **C**onsistency (일관성): 데이터는 DB의 **규칙(Rule)**을 항상 지킴. (예: "잔액은 0 이상")   
	- **I**solation (고립성): 여러 트랜잭션이 **서로를 방해하지 않음**. (마치 혼자 실행되는 것처럼)   
	- **D**urability (지속성): 성공한 결과는 시스템이 꺼져도 **영구적으로 보존**됨. (로그 기반)

## RDBMS vs. NoSQL의 ACID 구현 방식

- **RDBMS (올인원):** 데이터베이스가 **로그(Log)**, **잠금(Lock)**, **MVCC** 등의 기술을 통해 ACID의 네 가지 속성을 모두 **자동으로 보장**해 줍니다. 개발자는 트랜잭션의 시작과 끝만 알려주면 됩니다.   
- **NoSQL (개발자의 책임과 자유):**  
    - **단일 도큐먼트:** 도큐먼트 하나에 대한 작업은 **원자성(A)**과 **고립성(I)**을 쉽게 보장합니다.
    - **여러 도큐먼트:** RDBMS와 같은 ACID를 보장하지 않는 경우가 많습니다. 대신 **Saga 패턴**과 같은 아키텍처를 **애플리케이션에서 직접 구현**하여 **결과적 일관성**을 달성해야 합니다.
        - **보상 트랜잭션:** Saga 패턴에서 중간에 실패가 발생하면, 개발자가 직접 구현한 **'취소' 로직**을 통해 데이터의 정합성을 맞춥니다.

---

추가질문
- ? RDBMS가 ACID원칙을 내부적으로 어떻게 구현했을까?

- ? 최근 주목받는 NewSQL 데이터베이스(예: CockroachDB, TiDB)는 RDBMS의 ACID 특성과 NoSQL의 수평적 확장성을 모두 제공한다고 합니다. 이러한 데이터베이스는 어떤 원리로 두 가지 장점을 결합할 수 있었을까요?
	- ? 분산 합의 알고리즘이란?
	- ? 분산 트랜잭션 처리란?

	- ? 이런 장점에도 불구하고 CockroachDB를 많이 사용하지 않는 이유는?


- ? MSA(마이크로서비스 아키텍처) 환경에서 각 서비스가 자신만의 데이터베이스를 가질 때, 여러 서비스에 걸친 트랜잭션(분산 트랜잭션)의 일관성은 어떻게 보장할 수 있을까요?

- ? 데이터베이스의 고립성과 동시성이 트레이드 오프 관계에 있는 이유는?
	- 데이터베이스의 고립성(Isolation)을 높이면 동시성(Concurrency)이 떨어지고, 동시성을 높이면 고립성이 낮아지는 트레이드오프 관계가 있습니다. 실제 서비스 환경에서 어떤 격리 수준을 주로 사용하며, 그 이유는 무엇이라고 생각하나요?

- ? NoSQL을 사용하면 트랜잭션 처리가 불가능한가요?

- ? Saga 패턴에서 보상 트랜잭션(Compensating Transaction) 자체의 실패는 어떻게 처리해야 할까요? 보상 트랜잭션이 계속 실패한다면 데이터 불일치가 발생할 수 있는데, 이를 방지하기 위한 전략은 무엇이 있을까요?
	- 보상 트랜잭션 실패는 **재시도 -> DLQ와 알림 -> 수동 개입**의 단계적 방어 체계를 구축하여 처리하는 것이 일반적이며, 여기에 **멱등성 설계**가 반드시 뒷받침되어야 데이터의 최종 일관성을 보장할 수 있습니다.

- ? MVCC가 고전적인 잠금 방식에 비해 읽기 성능에 유리한 점은 명확합니다. 그렇다면 반대로 MVCC가 잠금 방식에 비해 불리한 점이나 더 복잡하게 만드는 측면은 무엇일까요?

- ? RDBMS의 `FOREIGN KEY` 제약 조건은 데이터의 무결성을 강력하게 보장해주지만, NoSQL에서는 이러한 제약 조건이 없는 경우가 대부분입니다. NoSQL을 사용하는 애플리케이션에서는 어떻게 데이터 간의 '관계'와 '참조 무결성'을 관리해야 할까요?

- ? MySQL같은 DB에서도 일부러 FK를 사용하지 않는 경우는 언제일까?
	- MSA 서비스
	- 높은 쓰기 처리량이 요구되는 서비스
	- 샤딩된 데이터베이스 환경

- ? FK대신 애플리케이션 단에서 무결성을 관리할때 얻을 수 있는 이점은?
	- 부모 row 조회시 캐싱 적용가능
	- 비즈니스 로직 검증 가능
		- FK는 단순히 부모 테이블에 행이 '존재하는지'만 검사함
	- 쓰기와 조회의 분리?
		- 부모 엔티티를 검증하는 조회 작업과 자식 엔티티를 저장하는 쓰기 작업을 분리하여 트랜잭션의 크기를 줄이고, DB 잠금이 발생하는 시간을 최소화할 수 있습니다.
	- @warning 하지만 사실상 애플리케이션 로직과 FK 모두를 사용해서 무결성을 관리하는게 일반적이고, 극단의 최적화가 필요한 경우에만 FK를 제거한다

- ? FK 외에, 데이터베이스 성능을 위해 의도적으로 포기하거나 다르게 사용하는 RDBMS의 기능이 있다면 어떤 것들이 있을까요? (예: 트리거, 저장 프로시저 등)

---

- @warning 단일 서버 RDBMS를 CAP 이론의 'CA' 형식에 해당한다고 분류하는 것은 엄밀히 말해 적절하지 않습니다. 그 이유는 말씀하신 대로 **CAP 이론 자체가 네트워크로 연결된 '분산 시스템'을 전제로 하기 때문**
- RDBMS에서 샤딩했을때 단점이 너무 커서 사실상 샤딩하는 의미가 없다? (JOIN 연산비용, 트랜잭션 연산비용)
- 비관적 락 vs 낙관적 락
