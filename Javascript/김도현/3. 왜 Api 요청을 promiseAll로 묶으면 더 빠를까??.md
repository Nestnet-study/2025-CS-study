
await 키워드를 쓰면 비동기가 강제적으로 동기 처리가 되어 코드가 순차적으로 수행된다.

```js
async function sequential() {
  console.log('1. 시작');
  const user = await fetch('/api/user');     // 첫 번째 fetch
  console.log('2. user 완료');
  const posts = await fetch('/api/posts');   // 두 번째 fetch  
  console.log('3. posts 완료');
  const comments = await fetch('/api/comments'); // 세 번째 fetch
  console.log('4. comments 완료');
}
```

위 api 동작의 순차적으로 이벤트 루프가 동작하는 것을 보면 아래와 같이 실행된다.
1. '1. 시작' 출력 (Call Stack)
2. fetch('/api/user') 실행
   → Web API로 네트워크 요청 시작
   → await으로 함수 일시정지
   → MicroTask Queue에 대기

3. 네트워크 응답 오면
   → MicroTask Queue에서 처리
   → '2. user 완료' 출력
   
4. fetch('/api/posts') 실행
   → 또 Web API로 요청
   → 또 await으로 일시정지
   → 또 MicroTask Queue 대기
   
5. 반복...

즉 api 요청이 2초씩 시간이 걸린다고 했을 때, 위처럼 3개의 API 요청은 순차적으로 실행되면서 6초의 소요시간이 걸리게 된다. **async/await의 함정**이라고도 불리는 것이 이 문제이다.




서로 관계가 없는 비동기 작업의 경우 `Promise.all()`로 한번에 처리 할 수 있다. 

```js
async function parallel() {
  console.log('1. 시작');
  
  // 모든 fetch가 동시에 시작됨!
  const [user, posts, comments] = await Promise.all([
    fetch('/api/user'),
    fetch('/api/posts'), 
    fetch('/api/comments')
  ]);
  
  console.log('2. 모두 완료');
}
```


1. '1. 시작' 출력 (Call Stack)

2. Promise.all 실행
   → fetch('/api/user') 즉시 실행 (Web API로 요청1 시작)
   → fetch('/api/posts') 즉시 실행 (Web API로 요청2 시작)  
   → fetch('/api/comments') 즉시 실행 (Web API로 요청3 시작)
   → await Promise.all로 함수 일시정지

3. 네트워크 응답들이 각각 도착할 때마다
   → 각각의 Promise가 MicroTask Queue에 들어감
   → 하지만 Promise.all은 모든 Promise 완료까지 기다림

4. 마지막 응답이 도착하면
   → Promise.all이 resolve됨
   → MicroTask Queue에서 처리
   → '2. 모두 완료' 출력

이 과정에서는 각 api가 2초씩 총 6초의 시간이 소요되는 것이 아닌, 동시에 시작하여 동시에 끝나 성능개선을 할 수 있다. 



```
Time 0ms:  Call Stack: [parallel()]
Time 0ms:  Web API: [fetch1, fetch2, fetch3 동시 시작]
Time 0ms:  MicroTask Queue: []

Time 800ms:  Web API: [fetch2, fetch3] (fetch1 먼저 완료)
Time 800ms:  MicroTask Queue: [fetch1.then()]

Time 900ms:  Web API: [fetch3] (fetch2 완료)  
Time 900ms:  MicroTask Queue: [fetch1.then(), fetch2.then()]

Time 1000ms: Web API: [] (fetch3 완료)
Time 1000ms: MicroTask Queue: [fetch1.then(), fetch2.then(), fetch3.then()]
            → Promise.all이 모든 결과를 수집하여 resolve
            → 전체 완료!
```

병렬처리를 시간적으로 보자면 위처럼 동작하게 되는데, 이때 주의해야할 점은 하나의 api가 많은 시간이 걸리게 되는 경우 전체 Promise.all()이 오래 걸리게 될 수 있다.

또한 task queue보다 MicroTask Queue가 우선순위가 높기 때문에 Promise.all()이 오래걸리는 경우 아래와 같은 문제가 발생할 수 있다.

- **UI 블로킹**: 버튼 클릭이 5초 후에야 반응
- **애니메이션 끊김**: requestAnimationFrame 지연
- **타이머 지연**: setTimeout/setInterval 정확도 떨어짐


즉 api 요청과 같이 비동기 작업을 수행할 때 async/await와 promise.all()을 사용할 때, 서로 상관없는 동작이기 때문에 순차적인 await보다 Promise.all()이 더 좋은 결과를 제공할 수도 있지만, 반대로 하나의 비동기 작업의 성능으로 인해 microtask queue가 쌓여 task queue의 작업도 방해하여 전체적인 성능하락을 야기할 수 있다.

상황을 보며 적절하게 사용하여야 한다.
