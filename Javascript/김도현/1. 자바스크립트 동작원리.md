## 1. 자바스크립트 비동기와 이벤트 루프
---

### 브라우저의 멀티 스레드로 작업을 동시에


- javascript는 <font color="#00b0f0">'싱글'</font>스레드라 한번의 하나의 작업만 수행할 수 있다.
	 대부분 웹애플리케이션에서는 네트워크요청이나 이벤트 처리, 타이머와 같이 작업을 멀티로 처리해야하는 경우가 많다. 어떻게 이럴 수 있을까??


- 네트워크 요청, 타이머, 애니메이션과 같은 오래걸리고 반복적인 작업들은 자바스크립트 엔진이 아닌 브라우저 내부의 멀티 스레드인 web APIs에서 <font color="#00b0f0">비동기 + 논블로킹</font>으로 처리된다.
	- ? **비동기+ 논블로킹:** 메인 스레드가 작업을 다른 곳에 요청하여 대신 실행하고, 그 작업이 완료되면 이벤트나 콜백 함수를 받아 결과를 실행하는 방식을 말한다.


- ? **비동기로 동작하는 핵심요소는 그러면 누가하는 걸까?** 자바스크립트 X, 브라우저라는 소프트웨어가 가지고 있거나, Node.js에서는 libuv 내장 라이브러리가 처리한다.

---
### 이벤트 루프는 브라우저 동작을 제어하는 관리자

![[image-21.png]]

- @ **Event Loop**: 브라우저의 동작 타이밍을 제어하는 관리자
	- 싱글 스레드인 자바스크립트의 작업을 멀티 스레드로 돌려 작업을 동시에 처리시키게 하던가, 또는 여러 작업 중 어떤 작업을 우선으로 동작시킬 것인지 결정하는 세심한 컨트롤을 하는 역할을 한다. 
	  
	- 브라우저 내부의 **Call Stack,** **Callback Queue**, **Web APIs**등의 요소들을 모니터링하면서 실행되는 작업을 관리하고, 흐름을 제어한다.


이벤트 루프의 동작 과정을 간단히 살펴보자면, 자바스크립트의 `setTimeout`이나 `fetch` 와 같은 비동기 자바스크립트 코드를 브라우저 **Web APIs**에게 맡기고, 백그라운드 작업이 끝난 결과를 콜백 함수 형태로 **큐(Callback Queue)** 에 넣고 처리 준비가 되면 **호출 스택(Call Stack)** 에 넣어 마무리 작업을 진행한다.





## 2. 자바스크립트 엔진 구동 환경
---

### Javascript 엔진

- 자바스크립트를 실행하기 위해서는 자바스크립트 엔진이 필요하다.
- 자바스크립트 엔진 = 자바스크립트 코드를 실행하는 <font color="#00b0f0">프로그램</font> or <font color="#00b0f0">인터프리터</font>
- 메모리 힙, 콜 스택으로 이루어져 있는 명백한 싱글 스레드 동작 방식이다. 

- 자바스크립트 엔진의 주요 구성요소로는 <font color="#00b0f0">메모리힙(Memory Heap)</font>과 <font color="#00b0f0">콜스택(Call Stack)</font>이 있다. 
	- **메모리 힙(Memory Heap)** : 메모리 할당이 일어나는 곳(창고)
	- **콜 스택(Call Stack)** : 호출 스택이 쌓이는 곳 (작업자)


- @ 메모리 힙
- 변수 선언, 함수 저장, 호출 등의 작업이 발생하는 공간
- `const num1 = 531;` 코드의 의미: num1이라는 변수를 위해 메모리 공간을 할당하고, 그 공간에 531이라는 값을 할당하는 것이다.
- 변수명, 함수명이라는 라벨이 붙어있는 박스들이 메모리, 이런 박스들을 보관하는 창고가 **Memory Heap**이다.

- @ 콜 스택
- 코드를 읽어내려가면서 수행할 작업들을 밑에서부터 하나씩 쌓고, 메모리 힙에서 작업 수행에 필요한 것들을 찾아서 작업을 수행하는 공간이다. 
- 콜 스택이란 기본적으로 우리가 프로그램 상에서 어디에 있는지를 기록하는 자료구조를 말한다. 만약 우리가 특정 함수를 실행하게 되면, 해당 함수는 콜 스택의 가장 상단에 위치하게 된다. 그리고 함수 실행이 끝나게 되면, 해당 함수는 콜 스택에서 제거되게 된다.


- **콜스택 동작 예시** 

```js
function multiply(x, y) {
    return x * y;
}
function printSquare(x) {
    var s = multiply(x, x);
    console.log(s);
}
printSquare(5);
```

![[image-22.png|529x397]]


call stack도 결국 스택이기 때문에 사이즈가 제한이 되어있다. 무한 루프를 도는 코드를 돌리면 Maximum call stack size 에러가 발생하게 된다. 스택오버플로우라고 볼 수 있다. 

```js
function foo() {
  foo();
}

foo();
```

![[image-23.png|516x387]]


---

###  브라우저 내부 구성도 

자바스크립트 비동기 코드의 동작과정에 관련된 구성 요소로는 Web APIs, Event Table, Callback Queue, Event Loop 등이 있다.

![[image-24.png]]


- <font color="#00b0f0">Call Stack</font> : 자바스크립트 엔진이 코드 실행을 위해 사용하는 메모리 구조
- <font color="#00b0f0">Heap</font> : 동적으로 생성된 자바스크립트 객체가 저장되는 공간
- <font color="#00b0f0">Web APIs</font>: 브라우저에서 제공하는 API 모음으로, 비동기적으로 실행되는 작업들을 전담하여 처리한다. (AJAX 호출, 타이머 함수, DOM 조작 등)
- <font color="#00b0f0">Callback Queue </font>: 비동기적 작업이 완료되면 실행되는 함수들이 대기하는 공간
- <font color="#00b0f0">Event Loop</font> : 비동기 함수들을 적절한 시점에 실행시키는 관리자
- <font color="#00b0f0">Event Table</font> : 특정 이벤트(timeout, click, mouse 등)가 발생했을 때 어떤 callback 함수가 호출되야 하는지를 알고 있는 자료구조 (위 그림에는 없음)



#### **Web APIs의 종류**

- @ Web APIs: 타이머, 네트워크 요청, 파일 입출력, 이벤트 처리 등 브라우저에서 제공하는 다양한 API를 포괄하는 총칭이다. 
- Web API는 브라우저(Chrome)에서 멀티 스레드로 구현되어 있음
	=> 그렇기 때문에 브라우저는 비동기 작업에 대해 메인 스레드를 차단하지 않고 다른 스레드를 사용하여 동시에 처리할수 있는 것이다.

![Web APIs|700x364](https://blog.kakaocdn.net/dna/EKfHg/btsepN6Bmc2/AAAAAAAAAAAAAAAAAAAAALU6MzJyDTkErc6ltOK76zzicoo4kNyn3gn9aXBNN_L5/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=kaxshA6ObXx8GqPFpIZSdXyA56s%3D)

예를 들어, `setTimeout` 비동기 작업은 Web APIs의 한 종류인 Timer API 에서 타이머 스레드를 사용하여 타이머를 수행한다. 마찬가지로, `XMLHttpRequest` , `fetch`와 같은 네트워크 관련 API는 네트워크 스레드를 사용하여 네트워크 요청과 응답을 처리된다.




![Web APIs](https://blog.kakaocdn.net/dna/BhZ5X/btscRYWrtIX/AAAAAAAAAAAAAAAAAAAAAEo9PgH5yTQn7XAvdz_vvZiBa9c46BUS_DcBTPIVV2Ht/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=QTZO9%2B5rz6I%2BugBsw34jtrNDVI4%3D)

- Web APIs의 대표적인 종류

- <font color="#00b0f0">DOM</font> : HTML 문서의 구조와 내용을 표현하고 조작할 수 있는 객체
- <font color="#00b0f0">XMLHttpRequest</font>: 서버와 비동기적으로 데이터를 교환할 수 있는 객체. AJAX기술의 핵심.
- <font color="#00b0f0">Timer API:</font> 일정한 시간 간격으로 함수를 실행하거나 지연시키는 메소드들을 제공
- <font color="#00b0f0">Console API</font> : 개발자 도구에서 콘솔 기능을 제공
- <font color="#00b0f0">Canvas API:</font> 'canvas' 요소를 통해 그래픽을 그리거나 애니메이션을 만들 수 있는 메소드들을 제공
- <font color="#00b0f0">Geolocation API</font>: 웹 브라우저에서 사용자의 현재 위치 정보를 얻을 수 있는 메소드들을 제공


- @ **모든 Web API들이 비동기는 아니다** = Web API에는 동기적으로 처리되는 것과 비동기적으로 처리되는 것이 모두 있다. ex DOM API나 Console API는 동기적으로 처리되고, XMLHttpRequest나 Timer API는 비동기적으로 처리된다.



#### **Callback Queue의 종류**

Web APIs가 여러 API들을 묶어 말하듯이, Callback Queue도 여러가지 종류의 Queue를 묶어 총칭하는 개념이다. Callback Queue에는 **(macro)task queue**와 **microtask queue** 두 가지 종류가 있다. 

![Callback Queue](https://blog.kakaocdn.net/dna/bjvMkH/btscRrduQdT/AAAAAAAAAAAAAAAAAAAAAM1-7UdNQN07bwDQThtg18qv9CXVUP5I9kdL8_fsmxvb/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=QGRLGZd1E1TN9UxnculcOukj4jQ%3D)

- <font color="#00b0f0">Task Queue</font> : `setTimeout`, `setInterval`, `fetch`, `addEventListener` 와 같이 비동기로 처리되는 함수들의 콜백 함수가 들어가는 큐 (macrotask queue 는 보통 task queue 라고 부른다)
- <font color="#00b0f0">Microtask Queue</font> : `promise.then`, `process.nextTick`, `MutationObserver` 와 같이 우선적으로 비동기로 처리되는 함수들의 콜백 함수가 들어가는 큐 (처리 우선순위가 높음)


- Callback Queue의 종류에 따라 이벤트 루프가 콜 스택으로 옮기는 순서가 달라진다.
- 일반적으로 microtask queue가 가장 우선순위가 높아 먼저 microtask queue를 처리하여 먼저 비우고 그라음 task queue의 콜백을 처리한다.



#### **AnimationFrame Queue**

- 애니메이션 큐를 담당하는 큐도 따로 존재한다.
- `requestAnimationFrame`메서드를 활용하여 콜백을 등록하면, 브라우저가 repaint직전에 AnimationFrame Queue에 있는 작업들을 전부 처리할 수 있다. 
- 애니메이션 타이밍을 관리하고 적절한 프레임속도를 유지하는 등 애니메이션을 관리할 수 있다. 


---
### **Node.js의 내부 구성도**

- NodeJs환경에서도 브라우저와 거의 비슷하지만, 내장된 libuv라이브러리를 활용하여 비동기 IO를 지원.
- 브라우저에서는 Web API를 사용하여 작업을 처리한다면, NodeJS에서는 Node.js. API를 사용하여 파일 시스템 액세스, 네트워크 액세스, 암호화, 압축 및 해제 등과 같은 다양한 작업을 처리
- Node.js에서 HTTP 요청을 수행하려면 http 모듈을 사용한다. 단, Node.js에서도 일부 Web API를 사용할 수 있는데, `setTimeout`, `setInterval` 등이 그렇다.


![Node.js](https://blog.kakaocdn.net/dna/bPLXeH/btsace2uNJ7/AAAAAAAAAAAAAAAAAAAAACOKFUN2TvcyHzV6Hr-xhXB9xJ7-1xTfh0ZAEq4p0yT-/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=UdJaerpEbvIUXiywe4Wbuc0u%2BmI%3D)

이처럼 Node.js에서 자바스크립트 엔진은 비동기 작업을 위해서 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 libuv 의 이벤트 루프를 통해 스케쥴되고 실행된다. Node.js의 내부 구성으로는 다음과 같다.

- <font color="#00b0f0">V8 (JavaScript 엔진) </font>: Node.js에서 사용하는 JavaScript 엔진으로 코드를 컴파일하고 실행한다
- <font color="#00b0f0">Bindings (Node API)</font> : Node.js 시스템과 V8 엔진 간의 상호작용을 가능하게 하는 C++ 라이브러리
- <font color="#00b0f0">Libuv 라이브러리</font> : Node.js에서 비동기 I/O 작업을 처리하기 위한 C 라이브러리
- <font color="#00b0f0">Event Queue</font> : 비동기 I/O 작업 결과를 저장하고 처리하기 위한 자료구조 (웹브라우저의 Task Queue와 비슷하다)
- <font color="#00b0f0">Event Loop </font>: Event Queue에 저장된 I/O 작업 결과를 처리하고, 다음 작업을 수행하도록 하는 관리자
- <font color="#00b0f0">Worker Threads</font> : CPU 집약적인 작업을 처리하기 위해 Node.js 10 버전부터 추가된 멀티 스레드. worker threads는 메인 스레드와 독립적인 V8 엔진 인스턴스를 가진다.




출처: [https://inpa.tistory.com/entry/🔄-자바스크립트-이벤트-루프-구조-동작-원리#자바스크립트_이벤트_루프_동작_과정](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8_%EC%9D%B4%EB%B2%A4%ED%8A%B8_%EB%A3%A8%ED%94%84_%EB%8F%99%EC%9E%91_%EA%B3%BC%EC%A0%95) 
출처: https://velog.io/@hang_kem_0531/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC 