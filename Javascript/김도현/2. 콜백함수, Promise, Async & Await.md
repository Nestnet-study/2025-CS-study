

## 콜백함수

콜백함수란? 함수에 파라미터로 들어갈 수 있는 함수를 말한다.

```js
function first(파라미터){
	파라미터();
}
first(function second(){})
```

이처럼 함수에 파라미터로 함수를 전달하는 방법을 그렇다면 언제 사용할까???
순서가 필요한 경우에 보통 사용한다.

`first()`다음에 `second()`함수가 순서대로 사용되기 위해서 콜백함수를 사용하기도 한다.

이러한 특성으로 인해 자바스크립트에서는 비동기 작업의 결과에 따라 다른 작업을 수행해야 할 때는 전통적으로 콜백함수를 사용했다. 함수내부에서 함수호출을 통해 비동기 작업의 결과를 받아서 인자로 주면 이를 통해 후속처리 작업을 수행했었다.


하지만 여러 개의 비동기 작업을 순차적으로 진행하면서 콜백함수가 중첩이 되다보면 코드의 깊이가 깊어져 가독성이 떨어진다. 이 상황을 <font color="#ff0000">콜백지옥(callback hell)</font>이라 부른다.

```js
setTimeout(() => {
   console.log('1단계 완료');
   setTimeout(() => {
       console.log('2단계 완료');
       setTimeout(() => {
           console.log('3단계 완료');
           setTimeout(() => {
               console.log('4단계 완료 - 지옥이다!');
           }, 1000);
       }, 1000);
   }, 1000);
}, 1000);
```

---
## Promise 객체

Promise 객체는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체이다. 어떤 비동기 작업의 결과를 제공하겠다는 '약속'을 반환한다는 의미에서 promise이다.

```js
const myPromise = new Promise((resolve, reject) => {
	// 비동기 작업 수행
    const data = fetch('서버로부터 요청할 URL');
    
    if(data)
    	resolve(data); // 만일 요청이 성공하여 데이터가 있다면
    else
    	reject("Error"); // 만일 요청이 실패하여 데이터가 없다면
})
```

promise객체는 비동기 작업이 성공하게 되면 `resolve()`를 호출하고, 실패한다면 `reject()` 메서드를 호출한다.

```js
myPromise
    .then((value) => { // 성공적으로 수행했을 때 실행될 코드
    	console.log("Data: ", value); // 위에서 return resolve(data)의 data값이 출력된다
    })
    .catch((error) => { // 실패했을 때 실행될 코드
     	console.error(error); // 위에서 return reject("Error")의 "Error"가 출력된다
    })
    .finally(() => { // 성공하든 실패하든 무조건 실행될 코드
    	
    })
```

 프로미스 객체는 이렇게 성공과 실패의 여부에따라 처리를 한다.
 `resolve()`가 실행되게 되면, `.then()`메서드의 콜백함수에서 성공에 대한 추가 처리를 진행한다.
 `reject()`가 실행되면, `.catch()`메서드의 콜백함수에서 실패했을 때의 추가 처리를 한다.
`.finally( )`는 성공 실패의 여부와 상관없이 해당 메서드 내부 콜백함수에서 추가 처리를 진행하게 된다.


이런 원리로 위의 **콜백지옥**문제는 
```js
const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

delay(1000)
    .then(() => console.log('1단계 완료'))
    .then(() => delay(1000))
    .then(() => console.log('2단계 완료'))
    .then(() => delay(1000))
    .then(() => console.log('3단계 완료'));
```

이처럼 promise로 어느정도 해결을 할 수 있다.

---
### Promise 메서드 정리

#### 1. Promise.resolve() / Promise.reject()

```javascript
// 바로 성공하는 Promise 만들기
Promise.resolve("성공!").then(console.log); // "성공!"

// 바로 실패하는 Promise 만들기  
Promise.reject("실패!").catch(console.log); // "실패!"
```

#### 2. Promise.all() - 모든 Promise 완료까지 기다림

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3])
  .then(console.log); // [1, 2, 3]
// 하나라도 실패하면 전체 실패
```

#### 3. Promise.allSettled() - 성공/실패 상관없이 모든 결과 받기

```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.reject("에러");

Promise.allSettled([p1, p2])
  .then(console.log); 
// [{status: "fulfilled", value: 1}, {status: "rejected", reason: "에러"}]
```

#### 4. Promise.any() - 가장 먼저 성공하는 하나만

```javascript
const slow = new Promise(resolve => setTimeout(() => resolve("느림"), 2000));
const fast = new Promise(resolve => setTimeout(() => resolve("빠름"), 1000));

Promise.any([slow, fast])
  .then(console.log); // "빠름" (1초 후)
```


---



## async / await

Promise와 다른 어떤 객체같은 것이 아닌, Promise를 더 쉽게 사용하고 비동기를 처리할 수 있도록 보이는 문법을 다르게 한 것이다.

async는 function 키워드 앞에만 붙이고, 비동기 작업이 필요한 곳 앞에 await만 붙여주면 된다. 

기존 promise에서 then과 catch를 많이 사용하면서 발생하는 프로미스 지옥(or콜백함수지옥)을 탈출 하게 해준 문법 중 하나이다.

```js
fetch("https://api.github.com/users")
  .then((response) => {
    if (response.ok) {
      return response.json();
    } else {
      throw new Error("Network Error");
    }
  })
  .then((users) => {
    return users.map((user) => user.login);
  })
  .then((logins) => {
    return logins.join(", ");
  })
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.error(error);
  });
```


```js
try {
    const response = await fetch("");
    
    if (response.ok) {
      const users = await response.json();
      const logins = users.map((user) => user.login);
      const result = logins.join(", ");
      console.log(result);
    } else {
      throw new Error("Network Error");
    }
    
} catch (error) {
	console.error(error);
}
```


async/ await을 사용하면서 가독성이 훨씬 좋아진 것을 볼 수 있다.
