


## 1. setTimeout과 setInterval


### setTimeout

`setTimeout`은 js에서 시간을 다루는 경우, 가장 먼저 생각하게 되는 함수이다.
```js
const timeoutID = setTimeout(function[, delay, arg1, arg2, ...]); 
```
매개변수로 함수와 시간을 받으며, 지정된 시간이 지나면 매개변수로 받은 함수를 실행한다.

```js
clearTimeout(timeoutId);
```
중간에 `setTimeout`함수를 중단하고 싶은 경우 `clearTimeout`으로 해당 timer ID를 통해 중지 시킬 수 있다.





---
### setInterval

`setInterval` 역시 매개변수로 함수와 시간을 가진다.
```js
const timeoutID = setInterval(function[, delay, arg1, arg2, ...]);
```

`setTimeout`과 동작은 유사하게 정해진 시간 이후 매개변수로 들어온 함수를 실행한다.
다른점은 그 시간마다 반복된다.

```js
const intervalId = setInterval(() => {
    console.log("실행!");
}, 1000);
```

위 예시 코드의 경우 

```
0초: setInterval 호출 (즉시 시작하지 않음)
1초 후: 첫 번째 실행
2초 후: 두 번째 실행
3초 후: 세 번째 실행
계속...: 1초 간격으로 반복
```

이처럼 동작하게 된다. 한 번만 실행되는 `setTimeout`과 다르게 반복적으로 실행이 되기 때문에 `setInterval`은 반드시 `clearInterval`을 해주어야 한다.



하지만 `setTimeout`과 `setInterval`에는 몇가지 함정이 존재한다.

### 2. setTimeout & setInterval는 "줄 세우기"가 아니라 "동시 타이머 시작"

```js
setTimeout(() => { console.log("첫 번째 메시지"); }, 5000); // 5초 타이머
setTimeout(() => { console.log("두 번째 메시지"); }, 3000); // 3초 타이머
setTimeout(() => { console.log("세 번째 메시지"); }, 1000); // 1초 타이머
```

이처럼 코드를 작성했을 때, 5초 3초 1초 순으로 순차적으로 실행되며 총 9초의 시간이 걸린다고 생각할 수 있지만, 실제로는 동시에 시작하기 때문에 각 1초 후, 3초 후, 5초 후 동작이 끝나게 된다.

```
0초: 세 개 타이머 모두 동시 시작 
1초: 세 번째 메시지 출력 (1초 타이머 완료) 
3초: 두 번째 메시지 출력 (3초 타이머 완료) 
5초: 첫 번째 메시지 출력 (5초 타이머 완료)
```

순차적으로 `setTimeout`을 실행하고 싶은 경우 중첩으로 해결해야한다.
```js
setTimeout(() => {
  console.log("첫 번째");
  setTimeout(() => {
    console.log("두 번째");
    setTimeout(() => {
      console.log("세 번째");
    }, 1000);
  }, 3000);
}, 5000);
```



### 3. setTimeout & setInterval는 정확한 시간을 보장하지 않는다.

![[image-29.png]]



```js
console.log("1");
setTimeout(() => { console.log("2"); }, 1000);
console.log("3");
```

이런 예제 코드가 있는 경우 Js엔진에서 코드를 해석하다가 `console.log("1");`을 만나게 되면 Call Stack에서 실행하고, `setTimeout()`을 만나게 되면 Web APIs로 보낸다. 

Web APIs에서는 1초를 기다리는 명령을 수행하고, 완료된 작업을 TaskQueue로 옮긴다.

하지만 이때 발생하는 문제는 크게 2가지 문제가 존재한다.
1. TaskQueue에서 CallStack으로 옮겨야 수행이 가능하다.
2. TaskQueue보다 MicroTask Queue가 우선순위가 더 높다.



1번 문제의 경우 CallStack에서 실행중인 코드가 존재한다면, TaskQueue에서 `console.log("2");`를 바로 CallStack으로 넘길 수가 없는 것이다. CallStack이 비어있어야 TaskQueue에서  CallStack으로 옮길 수 있기 때문이다.

CallStack이 꽉찬 예시로는 `console.log("3");`가 어떠한 이유로 인해 1초 뒤에 실행 중인 경우 1초를 기다린 `console.log("2");`가 바로 실행이 안되는 것이다.




2번 문제로는 `TaskQueue`말고도 Web APIs와 연결된 큐들이 존재하고 우선순위 이슈가 있는 문제이다.

Web APIs에는 크게 Task Queue, MicroTask Queue, Animation Queue 3가지가 존재하는데, 
`TaskQueue`가 `MicroTask Queue` 보다 우선순위가 낮다.

```js
console.log("1: API 요청 시작");

// fetch는 Promise를 반환 → Network API로 전달
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => response.json())  // Microtask Queue
    .then(data => {
        console.log("3: API 응답 받음", data.title);
    });

setTimeout(() => {
    console.log("4: setTimeout 실행");
}, 0);

console.log("2: 동기 코드 완료");

// 출력 순서:
// 1: API 요청 시작
// 2: 동기 코드 완료  
// 3: API 응답 받음 (Promise.then - Microtask)
// 4: setTimeout 실행 (Task)
```

이 코드의 경우와 같이 예상외로 `setTimeout`함수가 가장 늦은 순서로 콘솔이 찍히는 것을 확인할 수 있다. 이처럼 `Promise.all` 동작 같이 예상외로 오래 시간이 걸리는 경우 `setTimeOut`이 굉장히 딜레이가 될 수 있다.






## 4. 시간 보장이 필요한 코드 작성법


`requestAnimationFrame`를 사용하여 브라우저에서 계산하는 tick과 동기화 하는 방법이 존재하고, `Date` 객체를 활용해서도 가능하다.

```js
const [isRunning, setIsRunning] = useState(false);
const startTime = useRef(null);
const totalTime = useRef(0);

const toggle = () => {
  if (isRunning) {
    // 정지
    totalTime.current += Date.now() - startTime.current;
    setIsRunning(false);
  } else {
    // 시작
    startTime.current = Date.now();
    setIsRunning(true);
  }
};

// 현재 경과시간
const elapsed = isRunning 
  ? totalTime.current + (Date.now() - startTime.current)
  : totalTime.current;
```


이처럼 실제로는 개발할 때에 useRef와 Date객체를 활용해서 작성이 가능하며, 더 정밀도를 올리기 위해서는 `Date.now()`대신 `performance.now()`를 사용할 수 있다.

```js
Date.now()         // 1672531200000 (밀리초)
performance.now()  // 1234.5678912345 (마이크로초까지)
```